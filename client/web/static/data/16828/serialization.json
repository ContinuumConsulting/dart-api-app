{"name":"serialization","children":[{"name":"_lazy","children":[{"name":"l","kind":"param","id":"l"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"method","isPrivate":true,"comment":"Create a lazy list/map that will inflate its items on demand in [r]. ","id":"_lazy2()","line":"498"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Constructor","children":[{"name":"constructFrom","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"\nFind the field values in [state] and pass them to the constructor.\nIf any of [fieldNumbers] is not an int, then use it as a literal value.\n","id":"constructFrom2()","line":"606"},{"isFinal":true,"name":"type","kind":"variable","id":"type","line":"581"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"name","kind":"variable","id":"name","line":"584"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"int","refId":"dart.core/int"}]},"name":"fieldNumbers","kind":"variable","id":"fieldNumbers","line":"591"},{"name":"Constructor","children":[{"name":"type","kind":"param","id":"type"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"name","kind":"param","id":"name"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"int","refId":"dart.core/int"}]},"name":"fieldNumbers","kind":"param","id":"fieldNumbers"}],"kind":"constructor","comment":"\nCreates a new constructor for the [type] with the constructor named [name]\nand the [fieldNumbers] of the constructor fields.\n","id":"Constructor3()","line":"597"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis represents a constructor that is to be used when re-creating a\nserialized object.\n","id":"Constructor","line":"579"},{"name":"SetWithFunction","children":[{"name":"m","kind":"param","id":"m"},{"name":"object","kind":"param","id":"object"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"typedef","comment":"\n Provide a typedef for the setWith argument to setFieldWith. It would\nbe nice if we could put this closer to the definition.\n","id":"SetWithFunction","line":"573"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"BasicRule","children":[{"name":"setFieldWith","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"fieldName","kind":"param","id":"fieldName"},{"ref":{"name":"SetWithFunction","refId":"serialization/SetWithFunction"},"name":"setWith","kind":"param","id":"setWith"}],"kind":"method","comment":"\nSometimes it's necessary to treat fields of an object differently, based\non the containing object. For example, by default a list treats its\ncontents as non-essential state, so it will be populated only after all\nobjects have been created. An object may have a list which is used in its\nconstructor and must be fully created before the owning object can be\ncreated. Alternatively, it may not be possible to set a field directly,\nand some other method must be called to set it, perhaps calling a method\non the owning object to add each individual element.\n\nThis method lets you designate a function to use to set the value of a\nfield. It also makes the contents of that field be treated as essential,\nwhich currently only has meaning if the field is a list. This is done\nbecause you might set a list field's special treatment function to add\neach item individually and that will only work if those objects already\nexist.\n\nFor example, to serialize a Serialization, we need its rules to be\nindividually added rather than just setting the rules field.\n     ..addRuleFor(new Serialization()).setFieldWith('rules',\n         (InstanceMirror s, List rules) {\n           rules.forEach((x) => s.reflectee.addRule(x));\nNote that the function is passed the owning object as well as the field\nvalue, but that it is passed as a mirror.\n","id":"setFieldWith2()","line":"95"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"toString","kind":"method","id":"toString0()","line":"111"},{"name":"configureForMaps","kind":"method","comment":"\nConfigure this instance to use maps by field name as its output.\nInstances can either produce maps or lists. The list representation\nis much more compact and used by default. The map representation is\nmuch easier to debug. The default is to use lists.\n","id":"configureForMaps0()","line":"119"},{"name":"configureForLists","kind":"method","comment":"\nConfigure this instance to use lists accessing fields by index as its\noutput. Instances can either produce maps or lists. The list representation\nis much more compact and used by default. The map representation is\nmuch easier to debug. The default is to use lists.\n","id":"configureForLists0()","line":"129"},{"name":"createStateHolder","kind":"method","comment":"Create either a list or a map to hold the object's state, depending\non the [useMaps] variable. If using a Map, we wrap it in order to keep\nthe protocol compatible. See [configureForLists]/[configureForMaps].\n","id":"createStateHolder0()","line":"137"},{"name":"makeIndexableByNumber","children":[{"name":"state","kind":"param","id":"state"}],"kind":"method","comment":"Wrap the state if it's passed in as a map. ","id":"makeIndexableByNumber1()","line":"141"},{"name":"extractState","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"}],"kind":"method","comment":"\nExtract the state from [object] using an instanceMirror and the field\nnames in [fields]. Call the function [callback] on each value.\n","id":"extractState2()","line":"148"},{"name":"checkForEssentialLists","children":[{"name":"index","kind":"param","id":"index"},{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"\nIf the value is a List, and the field is a constructor field or\notherwise specially designated, we wrap it in something that indicates\na restriction on the rules that can be used. Which in this case amounts\nto designating the rule, since we so far only have one rule per object.\n","id":"checkForEssentialLists2()","line":"167"},{"name":"_unwrap","children":[{"name":"result","kind":"param","id":"result"}],"kind":"method","isPrivate":true,"comment":"Remove any MapWrapper from the extracted state. ","id":"_unwrap1()","line":"177"},{"name":"inflateEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"\nCall the designated constructor with the appropriate fields from [state],\nfirst resolving references in the context of [reader].\n","id":"inflateEssential2()","line":"183"},{"name":"inflateNonEssential","children":[{"name":"rawState","kind":"param","id":"rawState"},{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"For all [state] not required in the constructor, set it in the [object],\nresolving references in the context of [reader].\n","id":"inflateNonEssential3()","line":"192"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nDetermine if this rule applies to the object in question. In our case\nthis is true if the type mirrors are the same.\n","id":"appliesTo2()","line":"206"},{"returnType":{"name":"void","refId":"void"},"name":"_findFields","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"constructorFields","kind":"param","id":"constructorFields"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"regularFields","kind":"param","id":"regularFields"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"excludeFields","kind":"param","id":"excludeFields","line":"213"}],"kind":"method","isPrivate":true,"comment":"\nGiven the various field lists provided by the user, construct the list\nof field names that we want.\n","id":"_findFields3()","line":"212"},{"name":"_value","children":[{"name":"mirror","kind":"param","id":"mirror"},{"ref":{"name":"_Field","refId":"serialization/_Field"},"name":"field","kind":"param","id":"field"}],"kind":"method","isPrivate":true,"comment":"\nExtract the value of the field [fieldName] from the object reflected\nby [mirror].\n","id":"_value2()","line":"232"},{"name":"pullStateFrom","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"stream","kind":"param","id":"stream"}],"kind":"method","comment":"\nWhen reading from a flat format we are given [stream] and need to pull as\nmuch data from it as we need. Our format is that we have an integer N\nindicating the number of objects and then for each object N fields, which\nare references, where a reference is stored in the stream as two integers.\nOr, in the special case of null, two nulls.\n","id":"pullStateFrom1()","line":"241"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"constructorName","kind":"property","comment":"Return the name of the constructor used to create new instances on read.","id":"constructorName","line":"103"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"constructorFields","kind":"property","comment":"Return the list of field names to be passed to the constructor.","id":"constructorFields","line":"106"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"regularFields","kind":"property","comment":"Return the list of field names not used in the constructor. ","id":"regularFields","line":"109"},{"isFinal":true,"name":"type","kind":"variable","id":"type","line":"25"},{"ref":{"name":"Constructor","refId":"serialization/Constructor"},"name":"constructor","kind":"variable","id":"constructor","line":"28"},{"ref":{"name":"_FieldList","refId":"serialization/_FieldList"},"name":"fields","kind":"variable","id":"fields","line":"31"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"useMaps","kind":"variable","id":"useMaps","line":"38"},{"name":"BasicRule","children":[{"name":"type","kind":"param","id":"type"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"constructorName","kind":"param","id":"constructorName"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"constructorFields","kind":"param","id":"constructorFields","line":"62"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"regularFields","kind":"param","id":"regularFields","line":"62"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"excludeFields","kind":"param","id":"excludeFields","line":"63"}],"kind":"constructor","comment":"\nCreate this rule. Right now the user is obliged to pass a ClassMirror,\nbut once we allow class literals (Issue 6282) it will support that. The\nother parameters can all be left as null, and are optional on the\n[Serialization.addRule] method which is the normal caller for this.\n[constructorName] is the constructor, if not the default.\n[constructorFields] are the fields required to call the constructor, which\n  is the essential state. They don't have to be actual fields,\n  getter/setter pairs or getter/constructor pairs are fine. Note that\n  the constructorFields do not need to be strings, they can be arbitrary\n  values. For non-strings, these will be treated as constant values to be\n  used instead of data read from the objects.\n[regularFields] are the non-essential fields. They don't have to be actual\n  fields, getter/setter pairs are fine. If this is null, it's assumed\n  that we should figure them out.\n[excludeFields] lets you tell it to find the fields automatically, but\n  omit some that would otherwise be included.\n","id":"BasicRule5()","line":"61"}],"uri":"pkg/serialization/lib/src/basic_rule.dart","kind":"class","comment":"\nThis is the basic rule for handling \"normal\" objects, which have a list of\nfields and a constructor, as opposed to simple types or collections. It uses\nmirrors to access the state, and can also use them to figure out the list\nof fields and the constructor if it's not provided.\n\nIf you call [Serialization.addRule], this is what you get.\n\n","id":"BasicRule","line":"20"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"isAbstract":true,"name":"CustomRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"instance","kind":"param","id":"instance"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nReturn true if this rule applies to this object, in the context\nwhere we're writing it, false otherwise.\n","id":"appliesTo2()","line":"453"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"getState","children":[{"name":"instance","kind":"param","id":"instance"}],"kind":"method","comment":"\nSubclasses should implement this to return a list of the important fields\nin the object. The order of the fields doesn't matter, except that the\ncreate and setState methods need to know how to use it.\n","id":"getState1()","line":"460"},{"name":"create","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"}],"kind":"method","comment":"\nGiven a [List] of the object's [state], re-create the object. This should\ndo the minimum needed to create the object, just calling the constructor.\nSetting the remaining state of the object should be done in the [setState]\nmethod, which will be called only once all the objects are created, so\nit won't cause problems with cycles.\n","id":"create1()","line":"469"},{"returnType":{"name":"void","refId":"void"},"name":"setState","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"}],"kind":"method","comment":"\nSet any state in [object] which wasn't set in the constructor. Between\nthis method and [create] all of the information in [state] should be set\nin the new object.\n","id":"setState2()","line":"476"},{"name":"extractState","children":[{"name":"instance","kind":"param","id":"instance"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"f","kind":"param","id":"f"}],"kind":"method","id":"extractState2()","line":"478"},{"name":"inflateEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateEssential2()","line":"486"},{"returnType":{"name":"void","refId":"void"},"name":"inflateNonEssential","children":[{"name":"state","kind":"param","id":"state"},{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateNonEssential3()","line":"488"},{"name":"writeLengthInFlatFormat","kind":"property","id":"writeLengthInFlatFormat","line":"494"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis provides an abstract superclass for writing your own rules specific to\na class. It makes some assumptions about behaviour, and so can have a\nsimpler set of methods that need to be implemented in order to subclass it.\n\n","id":"CustomRule","line":"443"},{"superclass":{"name":"NamedObjectRule","refId":"serialization/NamedObjectRule"},"name":"MirrorRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","id":"appliesTo2()","line":"433"},{"name":"nameFor","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","id":"nameFor2()","line":"434"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles the special case of Mirrors, restricted to those that\nhave a simpleName. It knows that it applies to any such mirror and\nautomatically uses its simpleName as the key into the namedObjects.\nWhen reading, the user is still responsible for adding the appropriate\nmirrors to namedObject.\n","id":"MirrorRule","line":"432"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"NamedObjectRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"\nReturn true if this rule applies to the object. Checked by looking up\nin the namedObjects collection.\n","id":"appliesTo2()","line":"398"},{"name":"extractState","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"f","kind":"param","id":"f"}],"kind":"method","comment":"Extract the state of the named objects as just the object itself. ","id":"extractState2()","line":"403"},{"returnType":{"name":"void","refId":"void"},"name":"flatten","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"When we flatten the state we save it as the name. ","id":"flatten2()","line":"411"},{"name":"inflateEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"Look up the named object and return it. ","id":"inflateEssential2()","line":"416"},{"name":"inflateNonEssential","children":[{"name":"state","kind":"param","id":"state"},{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"Set any non-essential state on the object. For this rule, a no-op. ","id":"inflateNonEssential3()","line":"419"},{"name":"nameFor","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"Return the name for this object in the Writer. ","id":"nameFor2()","line":"422"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles things we can't pass directly, but only by reference.\nIf objects are listed in the namedObjects in the writer or serialization,\nit will save the name rather than saving the state.\n","id":"NamedObjectRule","line":"393"},{"superclass":{"name":"CustomRule","refId":"serialization/CustomRule"},"name":"ClosureRule","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","id":"appliesTo2()","line":"376"},{"name":"getState","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","id":"getState1()","line":"378"},{"name":"create","children":[{"name":"state","kind":"param","id":"state"}],"kind":"method","id":"create1()","line":"380"},{"name":"setState","children":[{"name":"object","kind":"param","id":"object"},{"name":"state","kind":"param","id":"state"}],"kind":"method","id":"setState2()","line":"382"},{"isFinal":true,"ref":{"name":"Type","refId":"dart.core/Type"},"name":"type","kind":"variable","id":"type","line":"357"},{"ref":{"name":"ConstructType","refId":"serialization/ConstructType"},"name":"construct","kind":"variable","id":"construct","line":"360"},{"ref":{"name":"GetStateType","refId":"serialization/GetStateType"},"name":"getStateFunction","kind":"variable","id":"getStateFunction","line":"363"},{"ref":{"name":"NonEssentialStateType","refId":"serialization/NonEssentialStateType"},"name":"setNonEssentialState","kind":"variable","id":"setNonEssentialState","line":"366"},{"name":"ClosureRule","children":[{"ref":{"name":"Type","refId":"dart.core/Type"},"name":"type","kind":"param","id":"type"},{"ref":{"name":"GetStateType","refId":"serialization/GetStateType"},"name":"getStateFunction","kind":"param","id":"getStateFunction"},{"ref":{"name":"ConstructType","refId":"serialization/ConstructType"},"name":"construct","kind":"param","id":"construct"},{"ref":{"name":"NonEssentialStateType","refId":"serialization/NonEssentialStateType"},"name":"setNonEssentialState","kind":"param","id":"setNonEssentialState","line":"374"}],"kind":"constructor","comment":"\nCreate a ClosureToMapRule for the given [type] which gets an object's\nstate by calling [getState], creates a new object by calling [construct]\nand sets the new object's state by calling [setNonEssentialState].\n","id":"ClosureRule4()","line":"373"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis is a rule where the extraction and creation are hard-coded as\nclosures. The result is expected to be a map indexed by field name.\n","id":"ClosureRule","line":"354"},{"returnType":{"name":"void","refId":"void"},"name":"NonEssentialStateType","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"m","kind":"param","id":"m"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"typedef","comment":"Typedef for the state-setting closure used in ClosureToMapRule. ","id":"NonEssentialStateType","line":"348"},{"returnType":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"GetStateType","children":[{"name":"object","kind":"param","id":"object"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"typedef","comment":"Typedef for the state-getting closure used in ClosureToMapRule. ","id":"GetStateType","line":"345"},{"name":"ConstructType","children":[{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"m","kind":"param","id":"m"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"typedef","comment":"Typedef for the object construction closure used in ClosureRule. ","id":"ConstructType","line":"342"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"PrimitiveRule","children":[{"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","id":"appliesTo2()","line":"297"},{"name":"extractState","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"f","kind":"param","id":"f"}],"kind":"method","id":"extractState2()","line":"300"},{"returnType":{"name":"void","refId":"void"},"name":"flatten","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","id":"flatten2()","line":"301"},{"name":"inflateEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateEssential2()","line":"302"},{"name":"inflateNonEssential","children":[{"name":"object","kind":"param","id":"object"},{"name":"_","kind":"param","isPrivate":true,"id":"_"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateNonEssential3()","line":"303"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"shouldUseReferenceFor","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nIndicate whether we should save pointers to this object as references\nor store the object directly. For primitives this depends on the format,\nso we delegate to the writer.\n","id":"shouldUseReferenceFor2()","line":"310"},{"returnType":{"name":"void","refId":"void"},"name":"dumpStateInto","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"ruleData","kind":"param","id":"ruleData"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"target","kind":"param","id":"target"}],"kind":"method","comment":"\nThis writes the data from our internal representation into a List.\nIt is used in order to write to a flat format, and is likely to be\nfolded into a more general mechanism for supporting different output\nformats. For primitives, the ruleData is our list of all the\nprimitives and just add it into the target.\n","id":"dumpStateInto2()","line":"320"},{"name":"pullStateFrom","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"stream","kind":"param","id":"stream"}],"kind":"method","comment":"\nWhen reading from a flat format we are given [stream] and need to pull as\nmuch data from it as we need. Our format is that we have an integer N\nindicating the number of objects and then N simple objects.\n","id":"pullStateFrom1()","line":"329"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles primitive types, defined as those that we can normally\nrepresent directly in the output format. We hard-code that to mean\nnum, String, and bool.\n","id":"PrimitiveRule","line":"296"},{"superclass":{"name":"ListRule","refId":"serialization/ListRule"},"name":"ListRuleEssential","children":[{"name":"inflateEssential","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","comment":"Create the new List and also inflate all of its contents. ","id":"inflateEssential2()","line":"279"},{"name":"inflateNonEssential","children":[{"name":"state","kind":"param","id":"state"},{"name":"newList","kind":"param","id":"newList"},{"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"Does nothing, because all the work has been done in inflateEssential. ","id":"inflateNonEssential3()","line":"286"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"mustBePrimary","kind":"property","id":"mustBePrimary","line":"288"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis is a subclass of ListRule where all of the list's contents are\nconsidered essential state. This is needed if an object X contains a List L,\nbut it expects L's contents to be fixed when X's constructor is called.\n","id":"ListRuleEssential","line":"276"},{"superclass":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"ListRule","children":[{"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","id":"appliesTo2()","line":"199"},{"name":"state","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"list","kind":"param","id":"list"}],"kind":"method","id":"state1()","line":"201"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"extractState","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"list","kind":"param","id":"list"},{"name":"f","kind":"param","id":"f"}],"kind":"method","id":"extractState2()","line":"203"},{"name":"inflateEssential","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateEssential2()","line":"212"},{"name":"inflateNonEssential","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"newList","kind":"param","id":"newList"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"inflateNonEssential3()","line":"216"},{"returnType":{"name":"void","refId":"void"},"name":"populateContents","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"state","kind":"param","id":"state"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"newList","kind":"param","id":"newList"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"populateContents3()","line":"220"},{"name":"pullStateFrom","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"stream","kind":"param","id":"stream"}],"kind":"method","comment":"\nWhen reading from a flat format we are given [stream] and need to pull as\nmuch data from it as we need. Our format is that we have an integer N\nindicating the number of objects and then for each object a length M,\nand then M references, where a reference is stored in the stream as two\nintegers. Or, in the special case of null, two nulls.\n","id":"pullStateFrom1()","line":"233"},{"returnType":{"name":"int","refId":"dart.core/int"},"name":"dataLengthIn","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"stream","kind":"param","id":"stream"}],"kind":"method","comment":"Return the length of the next list when reading the flat format. ","id":"dataLengthIn1()","line":"268"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"writeLengthInFlatFormat","kind":"property","comment":"\nReturn true because we need to write the length of each list in the flat\nformat. ","id":"writeLengthInFlatFormat","line":"265"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThis rule handles things that implement List. It will recreate them as\nwhatever the default implemenation of List is on the target platform.\n","id":"ListRule","line":"197"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"name":"SerializationRule","children":[{"isSetter":true,"returnType":{"name":"void","refId":"void"},"name":"number=","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","comment":"\nRules belong uniquely to a particular Serialization instance, and can\nbe identified within it by number.\n","id":"number=1()","line":"30"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"appliesTo","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"\nReturn true if this rule applies to this object, in the context\nwhere we're writing it, false otherwise.\n","id":"appliesTo2()","line":"40"},{"name":"extractState","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"f","kind":"param","id":"f"}],"kind":"method","comment":"\nThis extracts the state from the object, calling [f] for each value\nas it is extracted, and returning an object representing the whole\nstate at the end. The state that results will still have direct\npointers to objects, rather than references.\n","id":"extractState2()","line":"48"},{"returnType":{"name":"void","refId":"void"},"name":"flatten","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"method","comment":"\nGiven the variables representing the state of an object, flatten it\nby turning object pointers into Reference objects where needed. This\ndestructively modifies the state object.\n\nThis has a default implementation which assumes that object is indexable,\nso either conforms to Map or List. Subclasses may override to do something\ndifferent.\n","id":"flatten2()","line":"64"},{"name":"inflateEssential","children":[{"name":"state","kind":"param","id":"state"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"\nCreate the new object corresponding to [state] using the rules\nfrom [reader]. This may involve recursively inflating \"essential\"\nreferences in the state, which are those that are required for the\nobject's constructor. It is up to the rule what state is considered\nessential.\n","id":"inflateEssential2()","line":"94"},{"name":"inflateNonEssential","children":[{"name":"state","kind":"param","id":"state"},{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Reader","refId":"serialization/Reader"},"name":"reader","kind":"param","id":"reader"}],"kind":"method","comment":"\nThe [object] has already been created. Set any of its non-essential\nvariables from the representation in [state]. Where there are references\nto other objects they are resolved in the context of [reader].\n","id":"inflateNonEssential3()","line":"101"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"shouldUseReferenceFor","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nIf we have [object] as part of our state, should we represent that\ndirectly, or should we make a reference for it. By default we use a\nreference for everything.\n","id":"shouldUseReferenceFor2()","line":"108"},{"returnType":{"name":"void","refId":"void"},"name":"dumpStateInto","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"ruleData","kind":"param","id":"ruleData"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"target","kind":"param","id":"target"}],"kind":"method","comment":"\nThis writes the data from our internal representation into a List.\nIt is used in order to write to a flat format, and is likely to be\nfolded into a more general mechanism for supporting different output\nformats.\n","id":"dumpStateInto2()","line":"121"},{"name":"pullStateFrom","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"stream","kind":"param","id":"stream"}],"kind":"method","comment":"\nThe inverse of dumpStateInto, this reads the rule's state from an\niterator in a flat format.\n","id":"pullStateFrom1()","line":"152"},{"name":"dataLengthIn","children":[{"ref":{"name":"Iterator","refId":"dart.core/Iterator"},"name":"stream","kind":"param","id":"stream"}],"kind":"method","comment":"\nReturn the length of the list of data we expect to see on a particular\niterator in a flat format. This may have been encoded in the stream if we\nare variable length, or it may be constant. Returns null if the [Iterator]\nis empty.\n","id":"dataLengthIn1()","line":"183"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"number","kind":"property","comment":"\nRules belong uniquely to a particular Serialization instance, and can\nbe identified within it by number.\n","id":"number","line":"24"},{"name":"mustBePrimary","kind":"property","comment":"Return true if this rule should only be applied when we are the first\nrule found that applies to this object. This may or may not be a hack\nthat will disappear once we have better support for multiple rules.\nWe want to have multiple different rules that apply to the same object. We\nalso want to have multiple different rules that might exclusively apply\nto the same object. So, we want either ListRule or ListRuleEssential, and\nonly one of them can be there. But on the other hand, we may want both\nListRule and BasicRule. So we identify the kinds of rules that can share.\nIf mustBePrimary returns true, then this rule will only be chosen if no\nother rule has been found yet. This means that the ordering of rules in\nthe serialization is significant, which is unpleasant, but we'll have\nto see how bad it is.\n","id":"mustBePrimary","line":"85"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"writeLengthInFlatFormat","kind":"property","comment":"\nReturn true if this rule writes a length value before each entry in\nthe flat format. Return false if the results are fixed length.\n","id":"writeLengthInFlatFormat","line":"146"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"dataLength","kind":"property","comment":"\nIf the data is fixed length, return it here. Unused in the non-flat\nformat, or if the data is variable length.\n","id":"dataLength","line":"190"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"_number","kind":"variable","isPrivate":true,"id":"_number","line":"18"}],"uri":"pkg/serialization/lib/src/serialization_rule.dart","kind":"class","comment":"\nThe abstract superclass for serialization rules.\n","id":"SerializationRule","line":"13"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"DesignatedRuleForObject","children":[{"name":"possibleRules","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"rules","kind":"param","id":"rules"}],"kind":"method","id":"possibleRules1()","line":"652"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"rulePredicate","kind":"variable","id":"rulePredicate","line":"647"},{"isFinal":true,"name":"target","kind":"variable","id":"target","line":"648"},{"name":"DesignatedRuleForObject","children":[{"name":"target","kind":"param","id":"target"},{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"rulePredicate","kind":"param","id":"rulePredicate"}],"kind":"constructor","id":"DesignatedRuleForObject2()","line":"650"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThis is used during tracing to indicate that an object should be processed\nusing a particular rule, rather than the one that might ordinarily be\nfound for it. This normally only makes sense if the object is uniquely\nreferenced, and is a more or less internal collection. See ListRuleEssential\nfor an example. It knows how to return its object and how to filter.\n","id":"DesignatedRuleForObject","line":"646"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Reference","children":[{"name":"toJson","kind":"method","comment":"\nConvert the reference to a map in JSON format. This is specific to the\ncustom JSON format we define, and must be consistent with the\n[asReference] method.\n","id":"toJson0()","line":"626"},{"name":"writeToList","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"list","kind":"param","id":"list"}],"kind":"method","comment":"Write our information to [list]. Useful in writing to flat formats.","id":"writeToList1()","line":"633"},{"isFinal":true,"name":"parent","kind":"variable","id":"parent","line":"611"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"name":"ruleNumber","kind":"variable","id":"ruleNumber","line":"613"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"name":"objectNumber","kind":"variable","id":"objectNumber","line":"615"},{"name":"Reference","children":[{"name":"parent","kind":"param","id":"parent"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"ruleNumber","kind":"param","id":"ruleNumber"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"objectNumber","kind":"param","id":"objectNumber"}],"kind":"constructor","id":"Reference3()","line":"617"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nAny pointers to objects that can't be represented directly in the\nserialization format has to be stored as a reference. A reference encodes\nthe rule number of the rule that saved it in the Serialization that was used\nfor writing, and the object number within that rule.\n","id":"Reference","line":"609"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Trace","children":[{"name":"addRoot","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","id":"addRoot1()","line":"564"},{"name":"trace","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","comment":"A convenience method to add a single root and trace it in one step. ","id":"trace1()","line":"569"},{"name":"traceAll","kind":"method","comment":"\nProcess all of the objects reachable from our roots via state that the\nserialization rules access.\n","id":"traceAll0()","line":"578"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"hasProcessed","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","comment":"\nHas this object been seen yet? We test for this by checking if the\nwriter has a reference for it. See comment for _hasIndexFor.\n","id":"hasProcessed1()","line":"590"},{"name":"note","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"Note that we've seen [value], and add it to the queue to be processed. ","id":"note1()","line":"595"},{"isFinal":true,"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"variable","id":"writer","line":"551"},{"isFinal":true,"ref":{"name":"Queue","refId":"dart.core/Queue"},"name":"queue","kind":"variable","id":"queue","line":"557"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"roots","kind":"variable","id":"roots","line":"560"},{"name":"Trace","children":[{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"writer","kind":"param","id":"writer"}],"kind":"constructor","id":"Trace1()","line":"562"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThis represents the transitive closure of the referenced objects to be\nused for serialization. It works closely in conjunction with the Writer,\nand is kept as a separate object primarily for the possibility of wanting\nto plug in different sorts of tracing rules.\n","id":"Trace","line":"547"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Reader","children":[{"name":"objectNamed","children":[{"name":"key","kind":"param","id":"key"}],"kind":"method","comment":"\nLook up the reference to an external object. This can be held either in\nthe reader-specific list of externals or in the serializer's\n","id":"objectNamed1()","line":"350"},{"isSetter":true,"returnType":{"name":"void","refId":"void"},"name":"data=","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"name":"newData","kind":"param","id":"newData"}],"kind":"method","comment":"\nInternal use only, for testing purposes. Set the data for this reader\nto a List of Lists whose size must match the number of rules.\n","id":"data=1()","line":"370"},{"name":"read","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"input","kind":"param","id":"input"},{"ref":{"name":"Map","refId":"dart.core/Map"},"isOptional":true,"name":"externals","kind":"param","id":"externals"}],"kind":"method","comment":"\nThis is the primary method for a [Reader]. It takes the input data,\ncurrently hard-coded to expect our custom JSON format, and returns\nthe root object.\n","id":"read2()","line":"380"},{"returnType":{"name":"void","refId":"void"},"name":"readRules","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"newRules","kind":"param","id":"newRules"},{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"externals","kind":"param","id":"externals"}],"kind":"method","comment":"\nIf the data we are reading from has rules written to it, read them back\nand set them as the rules we will use.\n","id":"readRules2()","line":"395"},{"name":"readFlat","children":[{"ref":{"name":"List","refId":"dart.core/List"},"name":"input","kind":"param","id":"input"},{"ref":{"name":"Map","refId":"dart.core/Map"},"isOptional":true,"name":"externals","kind":"param","id":"externals"}],"kind":"method","comment":"\nThis is a hard-coded read method for a vaguely flat format. It's just a\nproof of concept of handling more flat formats right now, and needs a lot\nof fixing and generalization.\n","id":"readFlat2()","line":"410"},{"name":"inflateForRule","children":[{"name":"rule","kind":"param","id":"rule"}],"kind":"method","comment":"\nInflate all of the objects for [rule]. Does the essential state for all\nobjects first, then the non-essential state. This avoids cycles in\nnon-essential state, because all the objects will have already been\ncreated.\n","id":"inflateForRule1()","line":"446"},{"name":"inflateOne","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"},{"name":"position","kind":"param","id":"position"},{"name":"state","kind":"param","id":"state"}],"kind":"method","comment":"\nCreate a new object, based on [rule] and [state], which will\nbe stored in [position] in the storage for [rule]. This will\nfollow references and recursively inflate them, leaving Sentinel objects\nto detect cycles.\n","id":"inflateOne3()","line":"462"},{"name":"inflateReference","children":[{"name":"possibleReference","kind":"param","id":"possibleReference"}],"kind":"method","comment":"\nThe parameter [possibleReference] might be a reference. If it isn't, just\nreturn it. If it is, then inflate the target of the reference and return\nthe resulting object.\n","id":"inflateReference1()","line":"483"},{"name":"_objectFor","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"name":"reference","kind":"param","id":"reference"}],"kind":"method","isPrivate":true,"comment":"\nGiven [reference], return what we have stored as an object for it. Note\nthat, depending on the current state, this might be null or a Sentinel.\n","id":"_objectFor1()","line":"499"},{"name":"allObjectsForRule","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"}],"kind":"method","comment":"Given [rule], return the storage for its objects. ","id":"allObjectsForRule1()","line":"503"},{"name":"_stateFor","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"name":"reference","kind":"param","id":"reference"}],"kind":"method","isPrivate":true,"comment":"Given [reference], return the the state we have stored for it. ","id":"_stateFor1()","line":"506"},{"returnType":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"ruleFor","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"name":"reference","kind":"param","id":"reference"}],"kind":"method","comment":"Given a reference, return the rule it references. ","id":"ruleFor1()","line":"510"},{"name":"asReference","children":[{"name":"anObject","kind":"param","id":"anObject"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"name":"ifReference","kind":"param","id":"ifReference"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"name":"ifNotReference","kind":"param","id":"ifNotReference","line":"520"}],"kind":"method","comment":"\nGiven a possible reference [anObject], call either [ifReference] or\n[ifNotReference], depending if it's a reference or not. This is the\nprimary place that knows about the serialized representation of a\nreference.\n","id":"asReference3()","line":"519"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"SerializationRule","refId":"serialization/SerializationRule"}]},"name":"rules","kind":"property","comment":"\nReturn the list of rules to be used when writing. These come from the\n[serialization].\n","id":"rules","line":"363"},{"ref":{"name":"Serialization","refId":"serialization/Serialization"},"name":"serialization","kind":"variable","id":"serialization","line":"302"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"selfDescribing","kind":"variable","id":"selfDescribing","line":"308"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"name":"_data","kind":"variable","isPrivate":true,"id":"_data","line":"318"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"name":"objects","kind":"variable","id":"objects","line":"325"},{"ref":{"name":"Map","refId":"dart.core/Map"},"name":"namedObjects","kind":"variable","id":"namedObjects","line":"344"},{"name":"Reader","children":[{"ref":{"name":"Serialization","refId":"serialization/Serialization"},"name":"serialization","kind":"param","id":"serialization"}],"kind":"constructor","comment":"\nCreates a new [Reader] that uses the rules from its parent\n[Serialization]. Serializations do not keep any state related to\na particular read or write operation, so the same one can be used\nfor multiple different Writers/Readers.\n","id":"Reader1()","line":"333"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThe main class responsible for reading. It holds\nonto the necessary state and to the objects that have been inflated.\n","id":"Reader","line":"294"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Writer","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"name":"write","children":[{"name":"anObject","kind":"param","id":"anObject"}],"kind":"method","comment":"\nThis is the main API for a [Writer]. It writes the objects and returns\nthe serialized representation, currently a JSON format of a map\nwhose data is either lists indexed by field position or maps indexed\nby field name, and holding either primitives or references. See [toMaps]\n","id":"write1()","line":"75"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"writeFlat","children":[{"name":"anObject","kind":"param","id":"anObject"}],"kind":"method","comment":"\nThis is an alternate writing API that writes the objects and returns\nthe serialized representation as a List of simple objects.\nSee [toFlatFormat].\n","id":"writeFlat1()","line":"87"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"toFlatFormat","kind":"method","comment":"\nWrite to a simple flat format. This format is at the proof of concept\nstage, so details are not finalized and are likely to change in the future.\nRight now this produces a List containing null, int, and String. This is\nmore space-efficient than the map format created by [toStringFormat] or\n[toMaps], but is much less human-readable.\n","id":"toFlatFormat0()","line":"102"},{"returnType":{"name":"void","refId":"void"},"name":"_flatten","kind":"method","isPrivate":true,"comment":"\nGiven that we have fully populated the list of [states], and more\nimportantly, the list of [references], go through each state and turn\nanything that requires a [Reference] into one. Since only the rules\nknow the representation they use for state, delegate to them.\n","id":"_flatten0()","line":"133"},{"returnType":{"name":"void","refId":"void"},"name":"_process","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Trace","refId":"serialization/Trace"},"name":"trace","kind":"param","id":"trace"}],"kind":"method","isPrivate":true,"comment":"\nAs the [trace] processes each object, it will call this method on us.\nWe find the rules for this object, and record the state of the object\nas determined by each rule.\n","id":"_process2()","line":"148"},{"returnType":{"name":"void","refId":"void"},"name":"_record","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"}],"kind":"method","isPrivate":true,"comment":"\nRecord the state of [object] as determined by [rule] and keep\ntrack of it. Generate a [Reference] for this object if required.\nWhen it's required is up to the particular rule, but generally everything\ngets a reference except a primitive.\nNote that at this point the states are just the same as the fields of the\nobject, and haven't been flattened.\n","id":"_record2()","line":"163"},{"returnType":{"name":"void","refId":"void"},"name":"_addStateForRule","children":[{"name":"eachRule","kind":"param","id":"eachRule"},{"name":"state","kind":"param","id":"state"}],"kind":"method","isPrivate":true,"comment":"Record a [state] entry for a particular rule. ","id":"_addStateForRule2()","line":"180"},{"returnType":{"name":"int","refId":"dart.core/int"},"name":"_nextObjectNumberFor","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"}],"kind":"method","isPrivate":true,"comment":"Find what the object number for the thing we're about to add will be.","id":"_nextObjectNumberFor1()","line":"186"},{"returnType":{"name":"void","refId":"void"},"name":"_growStates","children":[{"name":"eachRule","kind":"param","id":"eachRule"}],"kind":"method","isPrivate":true,"comment":"\nWe store the states in a List, indexed by rule number. But rules can be\ndynamically added, so we may have to grow the list.\n","id":"_growStates1()","line":"195"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"_hasIndexFor","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","isPrivate":true,"comment":"\nReturn true if we have an object number for this object. This is used to\ntell if we have processed the object or not. This relies on checking if we\nhave a reference or not. That saves some space by not having to keep track\nof simple objects, but means that if someone refers to the identical string\nfrom several places, we will process it several times, and store it\nseveral times. That seems an acceptable tradeoff, and in cases where it\nisn't, it's possible to apply a rule for String, or even for Strings larger\nthan x, which gives them references.\n","id":"_hasIndexFor1()","line":"209"},{"returnType":{"name":"int","refId":"dart.core/int"},"name":"_objectNumberFor","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","isPrivate":true,"comment":"\nGiven an object, find what number it has. The number is valid only in\nthe context of a particular rule, and if the rule has more than one,\nthis will return the one for the primary rule, defined as the one that\nis listed in its canonical reference.\n","id":"_objectNumberFor1()","line":"219"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"toStringFormat","kind":"method","comment":"\nReturn the serialized data in string format. Currently hard-coded to\nour custom JSON format.\n","id":"toStringFormat0()","line":"228"},{"returnType":{"name":"Map","refId":"dart.core/Map"},"name":"toMaps","kind":"method","comment":"\nReturns the full serialized structure as nested maps. The top-level\nhas 3 fields, \"rules\" which may hold a definition of the rules used,\n\"data\" which holds the serialized data, and \"roots\", which holds\n[Reference] objects indicating the root objects. Note that roots are\nnecessary because the data is organized in the same way as the object\nstructure, it's a list of lists holding self-contained maps which only\nrefer to other parts via [Reference] objects.\nThis effectively defines a custom JSON serialization format, although\nthe details of the format vary depending which rules were used.\n","id":"toMaps0()","line":"243"},{"name":"_rootReferences","children":[{"name":"roots","kind":"param","id":"roots"}],"kind":"method","isPrivate":true,"comment":"\nReturn a list of [Reference] objects pointing to our roots. This will be\nstored in the output under \"roots\" in the default format.\n","id":"_rootReferences1()","line":"262"},{"name":"_referenceFor","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","isPrivate":true,"comment":"\nGiven an object, return a reference for it if one exists. If there's\nno reference, return null. Once we have finished the tracing step, all\nobjects that should have a reference (roughly speaking, non-primitives)\ncan be relied on to have a reference.\n","id":"_referenceFor1()","line":"271"},{"name":"hasNameFor","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","comment":"\nReturn true if the [namedObjects] collection has a reference to [object].\n","id":"hasNameFor1()","line":"279"},{"name":"nameFor","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","comment":"\nReturn the name we have for this object in the [namedObjects] collection.\n","id":"nameFor1()","line":"284"},{"name":"stateForReference","children":[{"ref":{"name":"Reference","refId":"serialization/Reference"},"name":"r","kind":"param","id":"r"}],"kind":"method","id":"stateForReference1()","line":"287"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"SerializationRule","refId":"serialization/SerializationRule"}]},"name":"rules","kind":"property","comment":"Return the list of rules we use. ","id":"rules","line":"54"},{"isFinal":true,"ref":{"name":"Serialization","refId":"serialization/Serialization"},"name":"serialization","kind":"variable","id":"serialization","line":"21"},{"ref":{"name":"Trace","refId":"serialization/Trace"},"name":"trace","kind":"variable","id":"trace","line":"25"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"selfDescribing","kind":"variable","id":"selfDescribing","line":"32"},{"isFinal":true,"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"Reference","refId":"serialization/Reference"}]},"name":"references","kind":"variable","id":"references","line":"40"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"List","refId":"dart.core/List"}]},"name":"states","kind":"variable","id":"states","line":"51"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"shouldUseReferencesForPrimitives","kind":"variable","id":"shouldUseReferencesForPrimitives","line":"177"},{"name":"Writer","children":[{"ref":{"name":"Serialization","refId":"serialization/Serialization"},"name":"serialization","kind":"param","id":"serialization"}],"kind":"constructor","comment":"\nCreates a new [Writer] that uses the rules from its parent\n[Serialization]. Serializations do not keep any state\nrelated to a particular read/write, so the same one can be used\nfor multiple different Readers/Writers.\n","id":"Writer1()","line":"62"}],"uri":"pkg/serialization/lib/src/reader_writer.dart","kind":"class","comment":"\nThis writes out the state of the objects to an external format. It holds\nall of the intermediate state needed. The primary API for it is the\n[write] method.\n","id":"Writer","line":"16"},{"interfaces":[{"name":"Exception","refId":"dart.core/Exception"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"SerializationException","children":[{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"name":"message","kind":"variable","id":"message","line":"438"},{"name":"SerializationException","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"name":"message","kind":"param","id":"message"}],"kind":"constructor","id":"SerializationException1()","line":"439"}],"kind":"class","comment":"\nAn exception class for errors during serialization.\n","id":"SerializationException","line":"437"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Serialization","children":[{"isSetter":true,"name":"selfDescribing=","children":[{"name":"x","kind":"param","id":"x"}],"kind":"method","comment":"\nWhen we write out data using this serialization, should we also write\nout a description of the rules. This is on by default unless using\nCustomRule subclasses, in which case it requires additional setup and\nis off by default.\n","id":"selfDescribing=1()","line":"214"},{"returnType":{"name":"BasicRule","refId":"serialization/BasicRule"},"name":"addRuleFor","children":[{"name":"instanceOfType","kind":"param","id":"instanceOfType","line":"258"},{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"name":"constructor","kind":"param","id":"constructor","line":"259"},{"ref":{"name":"List","refId":"dart.core/List"},"isOptional":true,"name":"constructorFields","kind":"param","id":"constructorFields","line":"260"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"isOptional":true,"name":"fields","kind":"param","id":"fields","line":"261"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"String","refId":"dart.core/String"}]},"isOptional":true,"name":"excludeFields","kind":"param","id":"excludeFields","line":"262"}],"kind":"method","comment":"\nCreate a [BasicRule] rule for the type of\n[instanceOfType]. Optionally\nallows specifying a [constructor] name, the list of [constructorFields],\nand the list of [fields] not used in the constructor. Returns the new\nrule. Note that [BasicRule] uses reflection, and so will not work with the\ncurrent state of dartj2s. If you need to run there, consider using\n[CustomRule] instead.\n\nIf the optional parameters aren't specified, the default constructor will\nbe used, and the list of fields will be computed. Alternatively, you can\nomit [fields] and provide [excludeFields], which will then compute the\nlist of fields specifically excluding those listed.\n\nThe fields can be actual public fields, but can also be getter/setter\npairs or getters whose value is provided in the constructor. For the\n[constructorFields] they can also be arbitrary objects. Anything that is\nnot a String will be treated as a constant value to be used in any\nconstruction of these objects.\n\nIf the list of fields is computed, fields from the superclass will be\nincluded. However, each subclass needs its own rule, since the constructors\nare not inherited, and so may need to be specified separately for each\nsubclass.\n","id":"addRuleFor5()","line":"257"},{"returnType":{"name":"void","refId":"void"},"name":"addDefaultRules","kind":"method","comment":"Set up the default rules, for lists and primitives. ","id":"addDefaultRules0()","line":"274"},{"returnType":{"name":"void","refId":"void"},"name":"addRule","children":[{"ref":{"name":"SerializationRule","refId":"serialization/SerializationRule"},"name":"rule","kind":"param","id":"rule"}],"kind":"method","comment":"\nAdd a new SerializationRule [rule]. The addRuleFor method will probably\nhandle most simple cases, but for adding an arbitrary rule, including\na SerializationRule subclass which you have created, you can use this\nmethod.\n","id":"addRule1()","line":"288"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"write","children":[{"ref":{"name":"Object","refId":"dart.core/Object"},"name":"object","kind":"param","id":"object"}],"kind":"method","comment":"\nThis is the basic method to write out an object graph rooted at\n[object] and return the result. Right now this is hard-coded to return\na String from a custom [JSON] format, but that is likely to change to be\nmore pluggable in the near future.\n","id":"write1()","line":"299"},{"returnType":{"name":"Writer","refId":"serialization/Writer"},"name":"newWriter","kind":"method","comment":"\nReturn a new [Writer] object for this serialization. This is useful if you\nwant to do something more complex with the writer than just returning\nthe final result.\n","id":"newWriter0()","line":"308"},{"returnType":{"name":"List","refId":"dart.core/List"},"name":"writeFlat","children":[{"ref":{"name":"Object","refId":"dart.core/Object"},"name":"object","kind":"param","id":"object"}],"kind":"method","comment":"\nWrite out the tree in a custom flat format, returning a list containing\nonly \"simple\" types: num, String, and bool.\n","id":"writeFlat1()","line":"314"},{"name":"read","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"input","kind":"param","id":"input"},{"ref":{"name":"Map","refId":"dart.core/Map"},"isOptional":true,"name":"externals","kind":"param","id":"externals"}],"kind":"method","comment":"\nRead the serialized data from [input] and return the root object\nfrom the result. If there are objects that need to be resolved\nin the current context, they should be provided in [externals] as a\nMap from names to values. In particular, in the current implementation\nany class mirrors needed should be provided in [externals] using the\nclass name as a key. In addition to the [externals] map provided here,\nvalues will be looked up in the [externalObjects] map.\n","id":"read2()","line":"327"},{"returnType":{"name":"Reader","refId":"serialization/Reader"},"name":"newReader","kind":"method","comment":"\nReturn a new [Reader] object for this serialization. This is useful if\nyou want to do something more complex with the reader than just returning\nthe final result.\n","id":"newReader0()","line":"336"},{"returnType":{"name":"List","refId":"dart.core/List","arguments":[{"name":"SerializationRule","refId":"serialization/SerializationRule"}]},"name":"rulesFor","children":[{"name":"object","kind":"param","id":"object"},{"ref":{"name":"Writer","refId":"serialization/Writer"},"name":"w","kind":"param","id":"w"}],"kind":"method","comment":"\nReturn the list of SerializationRule that apply to [object]. For\ninternal use, but public because it's used in testing.\n","id":"rulesFor2()","line":"342"},{"returnType":{"name":"Serialization","refId":"serialization/Serialization"},"name":"_ruleSerialization","kind":"method","isPrivate":true,"comment":"\nCreate a Serialization for serializing SerializationRules. This is used\nto save the rules in a self-describing format along with the data.\nIf there are new rule classes created, they will need to be described\nhere.\n","id":"_ruleSerialization0()","line":"389"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"_hasNameFor","children":[{"name":"object","kind":"param","id":"object"}],"kind":"method","isPrivate":true,"comment":"Return true if our [namedObjects] collection has an entry for [object].","id":"_hasNameFor1()","line":"417"},{"name":"_nameFor","children":[{"name":"object","kind":"param","id":"object"},{"isOptional":true,"name":"ifAbsent","kind":"param","id":"ifAbsent"}],"kind":"method","isPrivate":true,"comment":"\nReturn the name we have for [object] in our [namedObjects] collection or\nthe result of evaluating [ifAbsent] if there is no entry.\n","id":"_nameFor2()","line":"426"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"rules","kind":"property","comment":"\nThe serialization is controlled by the list of Serialization rules. These\nare most commonly added via [addRuleFor].\n","id":"rules","line":"176"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"selfDescribing","kind":"property","comment":"\nWhen we write out data using this serialization, should we also write\nout a description of the rules. This is on by default unless using\nCustomRule subclasses, in which case it requires additional setup and\nis off by default.\n","id":"selfDescribing","line":"203"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"_rules","kind":"variable","isPrivate":true,"id":"_rules","line":"170"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"}]},"name":"namedObjects","kind":"variable","id":"namedObjects","line":"187"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"_selfDescribing","kind":"variable","isPrivate":true,"id":"_selfDescribing","line":"195"},{"name":"Serialization","kind":"constructor","comment":"\nCreates a new serialization with a default set of rules for primitives\nand lists.\n","id":"Serialization0()","line":"220"},{"name":"Serialization.blank","kind":"constructor","comment":"\nCreates a new serialization with no default rules at all. The most common\nuse for this is if we are reading self-describing serialized data and\nwill populate the rules from that data.\n","id":"Serialization.blank0()","line":"229"}],"kind":"class","comment":"\nThis class defines a particular serialization scheme, in terms of\n[SerializationRule] instances, and supports reading and writing them.\nSee library comment for examples of usage.\n","id":"Serialization","line":"164"}],"uri":"pkg/serialization/lib/serialization.dart","kind":"library","comment":"\nThis provides a general-purpose serialization facility for Dart objects. A\n[Serialization] is defined in terms of [SerializationRule]s and supports\nreading and writing to different formats.\n\nSetup\n=====\nA simple example of usage is\n\n     var address = new Address();\n     address.street = 'N 34th';\n     address.city = 'Seattle';\n     var serialization = new Serialization()\n         ..addRuleFor(address);\n     String output = serialization.write(address);\n\nThis creates a new serialization and adds a rule for address objects. Right\nnow it has to be passed an address instance because we can't write Address\nas a literal. Then we ask the Serialization to write the address and we get\nback a String which is a [JSON] representation of the state of it and related\nobjects.\n\nThe version above used reflection to automatically identify the public\nfields of the address object. We can also specify those fields explicitly.\n\n     var serialization = new Serialization()\n       ..addRuleFor(address,\n           constructor: \"create\",\n           constructorFields: [\"number\", \"street\"],\n           fields: [\"city\"]);\n\nThis rule still uses reflection to access the fields, but does not try to\nidentify which fields to use, but instead uses only the \"number\" and \"street\"\nfields that we specified. We may also want to tell it to identify the\nfields, but to specifically omit certain fields that we don't want\nserialized.\n\n     var serialization = new Serialization()\n       ..addRuleFor(address,\n           constructor: \"\",\n           excludeFields: [\"other\", \"stuff\"]);\n\nWe can also use a completely non-reflective rule to serialize and\nde-serialize objects. This can be more cumbersome, but it does work in\ndart2js, where mirrors are not yet implemented.\n\n     addressToMap(a) => {\"number\" : a.number, \"street\" : a.street,\n         \"city\" : a.city};\n     createAddress(Map m) => new Address.create(m[\"number\"], m[\"street\"]);\n     fillInAddress(Map m, Address a) => a.city = m[\"city\"];\n     var serialization = new Serialization()\n       ..addRule(\n           new ClosureToMapRule(anAddress.runtimeType,\n               addressToMap, createAddress, fillInAddress);\n\nNote that there are three different functions provided. The addressToMap\nfunction takes the fields we want serialized from the Address and puts them\ninto a map. The createAddress function creates a new address using a map like\nthe one returned by the first function. And the fillInAddress function fills\nin any  remaining state in the created object.\n\nAt the moment, however, using this rule increases the probability of problems\nwith cycles. The problem is that before passing values to the user-supplied\nfunctions it has to inflate any references to be the real objects. Since it\ndoesn't know which ones the creation function uses it has to inflate all of\nthem. For example, consider a Node class with parent, leftChild, and\nrightChild, and the parent field was final and set in the constructor. When\nwe inflate all of the values we will end up with a cycle and can't\nde-serialize. If we know which fields are used by the constructor we can\ninflate only those, which is what BasicRule does. We expect to make a richer\nAPI for rules not using reflection, but there's a tension between providing\nthe serialization process with enough information and making it more work\nto specify.\n\nThere are cases where the constructor needs values that we can't easily get\nthe serialized object. For example, we may just want to pass null, or a\nconstant value. To support this, we can specify as constructor fields\nvalues that aren't field names. If any value isn't a String, it will be\ntreated as a constant and passed unaltered to the constructor.\n\nIn some cases a non-constructor field should not be set using field\naccess or a setter, but should be done by calling a method. For example, it\nmay not be possible to set a List field \"foo\", and you need to call an\naddFoo() method for each entry in the list. In these cases, if you are using\na BasicRule for the object you can call the setFieldWith() method.\n\n      s..addRuleFor(fooHolderInstance).setFieldWith(\"foo\",\n          (parent, value) => for (var each in value) parent.addFoo(value));\n\nWriting\n=======\nTo write objects, we use the write() methods. There are two variations.\n\n      String output = serialization.write(someObject);\n      List output = serialization.writeFlat(someObject);\n\nThe first uses a representation in which objects are represented as maps\nkeyed by field name, but in which references between objects have been\nconverted into Reference objects. This is then encoded as a [JSON] string.\n\nThe second representation holds all the objects as a List of simple types.\nFor practical use you may want to convert that to a [JSON] or other encoded\nrepresentation as well.\n\nBoth representations are primarily intended as proofs of concept for\ndifferent types of representation, and we expect to generalize that to a\npluggable mechanism for different representations.\n\nReading\n=======\nTo read objects, the corresponding methods are [read] and [readFlat].\n\n      List input = serialization.read(aString);\n      List input = serialization.readFlat(aList);\n\nThere is also a convenience method for the case of reading a single object.\n\n      Object result = serialization.readOne(aString);\n      Object result = serialization.readOneFlat(aString);\n\nWhen reading, the serialization instance doing the reading must be configured\nwith compatible rules to the one doing the writing. It's possible for the\nrules to be different, but they need to be able to read the same\nrepresentation. For most practical purposes right now they should be the\nsame. The simplest way to achieve this is by having the serialization\nvariable [selfDescribing] be true. In that case the rules themselves are also\nstored along with the serialized data, and can be read back on the receiving\nend. Note that this does not yet work for [ClosureToMapRule]. The\n[selfDescribing] variable is true by default.\n\nWhen reading, some object references should not be serialized, but should be\nconnected up to other instances on the receiving side. A notable example of\nthis is when serialization rules have been stored. Instances of BasicRule\ntake a [ClassMirror] in their constructor, and we cannot serialize those. So\nwhen we read the rules, we must provide a Map<String, Object> which maps from\nthe simple name of classes we are interested in to a [ClassMirror]. This can\nbe provided either in the [externalObjects] variable of the Serialization,\nor as an additional parameter to the reading methods.\n\n    new Serialization()\n      ..addRuleFor(new Person(), constructorFields: [\"name\"])\n      ..externalObjects['Person'] = reflect(new Person()).type;\n","id":"serialization","line":"148"}
{"name":"dart.isolate","children":[{"returnType":{"name":"IsolateSink","refId":"dart.isolate/IsolateSink"},"name":"streamSpawnUri","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"uri","kind":"param","id":"uri"}],"uri":"sdk/lib/isolate/isolate_stream.dart","kind":"method","comment":"\nCreates and spawns an isolate whose code is available at [uri].  Like with\n[streamSpawnFunction], the child isolate will have a default [IsolateStream],\nand a this function returns an [IsolateSink] feeding into it.\n\nSee comments at the top of this library for more details.\n","id":"streamSpawnUri1()","line":"212"},{"returnType":{"name":"IsolateSink","refId":"dart.isolate/IsolateSink"},"name":"streamSpawnFunction","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"topLevelFunction","kind":"param","id":"topLevelFunction"}],"uri":"sdk/lib/isolate/isolate_stream.dart","kind":"method","comment":"\nCreates and spawns an isolate that shares the same code as the current\nisolate, but that starts from [topLevelFunction]. The [topLevelFunction]\nargument must be a static top-level function or a static method that takes no\narguments.\n\nWhen any isolate starts (even the main script of the application), a default\n[IsolateStream] is created for it. This sink is available from the top-level\ngetter [stream] defined in this library.\n\n[spawnFunction] returns an [IsolateSink] feeding into the child isolate's\ndefault stream.\n\nSee comments at the top of this library for more details.\n","id":"streamSpawnFunction1()","line":"200"},{"returnType":{"name":"SendPort","refId":"dart.isolate/SendPort"},"name":"spawnUri","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"uri","kind":"param","id":"uri"}],"uri":"sdk/lib/isolate/base.dart","kind":"method","comment":"\nCreates and spawns an isolate whose code is available at [uri].  Like with\n[spawnFunction], the child isolate will have a default [ReceivePort], and a\nthis function returns a [SendPort] derived from it.\n\nSee comments at the top of this library for more details.\n","id":"spawnUri1()","line":"47"},{"returnType":{"name":"SendPort","refId":"dart.isolate/SendPort"},"name":"spawnFunction","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"topLevelFunction","kind":"param","id":"topLevelFunction"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"name":"UnhandledExceptionCallback","kind":"param","id":"UnhandledExceptionCallback","line":"37"}],"uri":"sdk/lib/isolate/base.dart","kind":"method","comment":"\nCreates and spawns an isolate that shares the same code as the current\nisolate, but that starts from [topLevelFunction]. The [topLevelFunction]\nargument must be a static top-level function or a static method that takes no\narguments. It is illegal to pass a function closure.\n\nWhen any isolate starts (even the main script of the application), a default\n[ReceivePort] is created for it. This port is available from the top-level\ngetter [port] defined in this library.\n\n[spawnFunction] returns a [SendPort] derived from the child isolate's default\nport.\n\nSee comments at the top of this library for more details.\n","id":"spawnFunction2()","line":"36"},{"returnType":{"name":"ReceivePort","refId":"dart.isolate/ReceivePort"},"name":"port","uri":"sdk/lib/isolate/base.dart","kind":"method","comment":"\nThe initial [ReceivePort] available by default for this isolate. This\n[ReceivePort] is created automatically and it is commonly used to establish\nthe first communication between isolates (see [spawnFunction] and\n[spawnUri]).\n","id":"port0()","line":"19"},{"ref":{"name":"ReceivePort","refId":"dart.isolate/ReceivePort"},"name":"port","uri":"sdk/lib/isolate/base.dart","kind":"property","comment":"\nThe initial [ReceivePort] available by default for this isolate. This\n[ReceivePort] is created automatically and it is commonly used to establish\nthe first communication between isolates (see [spawnFunction] and\n[spawnUri]).\n","id":"port","line":"19"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"_ISOLATE_STREAM_TOKEN","uri":"sdk/lib/isolate/isolate_stream.dart","kind":"variable","isPrivate":true,"id":"_ISOLATE_STREAM_TOKEN","line":"38"},{"isFinal":true,"ref":{"name":"IsolateStream","refId":"dart.isolate/IsolateStream"},"name":"stream","uri":"sdk/lib/isolate/isolate_stream.dart","kind":"variable","id":"stream","line":"13"},{"superclass":{"name":"StreamSink","refId":"dart.async/StreamSink","arguments":[]},"name":"IsolateSink","children":[{"returnType":{"name":"void","refId":"void"},"name":"add","children":[{"name":"message","kind":"param","id":"message"}],"kind":"method","comment":"\nSends an asynchronous [message] to the linked [IsolateStream]. The message\nis copied to the receiving isolate.\n\nThe content of [message] can be: primitive values (null, num, bool, double,\nString), instances of [IsolateSink]s, and lists and maps whose elements are\nany of these. List and maps are also allowed to be cyclic.\n\nIn the special circumstances when two isolates share the same code and are\nrunning in the same process (e.g. isolates created via [spawnFunction]), it\nis also possible to send object instances (which would be copied in the\nprocess). This is currently only supported by the dartvm.  For now, the\ndart2js compiler only supports the restricted messages described above.\n","id":"add1()","line":"147"},{"returnType":{"name":"void","refId":"void"},"name":"signalError","children":[{"ref":{"name":"AsyncError","refId":"dart.async/AsyncError"},"name":"errorEvent","kind":"param","id":"errorEvent"}],"kind":"method","id":"signalError1()","line":"152"},{"name":"_mangleMessage","children":[{"name":"message","kind":"param","id":"message"}],"kind":"method","isPrivate":true,"id":"_mangleMessage1()","line":"156"},{"returnType":{"name":"void","refId":"void"},"name":"close","kind":"method","id":"close0()","line":"167"},{"isOperator":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"==","children":[{"name":"other","kind":"param","id":"other"}],"kind":"method","comment":"\nTests whether [other] is an [IsolateSink] feeding into the same\n[IsolateStream] as this one.\n","id":"==1()","line":"177"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"hashCode","kind":"property","id":"hashCode","line":"181"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"_isClosed","kind":"variable","isPrivate":true,"id":"_isClosed","line":"129"},{"isFinal":true,"ref":{"name":"SendPort","refId":"dart.isolate/SendPort"},"name":"_port","kind":"variable","isPrivate":true,"id":"_port","line":"130"},{"name":"IsolateSink._fromPort","children":[{"ref":{"name":"SendPort","refId":"dart.isolate/SendPort"},"name":"_port","kind":"param","isPrivate":true,"id":"_port"}],"kind":"constructor","isPrivate":true,"id":"IsolateSink._fromPort1()","line":"131"}],"uri":"sdk/lib/isolate/isolate_stream.dart","kind":"class","comment":"\n[IsolateSink]s represent the feed for [IsolateStream]s. Any message written\nto [this] is delivered to its respective [IsolateStream]. [IsolateSink]s are\ncreated by [MessageBox]es.\n\n[IsolateSink]s can be transmitted to other isolates.\n","id":"IsolateSink","line":"128"},{"superclass":{"name":"Stream","refId":"dart.async/Stream","arguments":[]},"name":"IsolateStream","children":[{"returnType":{"name":"void","refId":"void"},"name":"_add","children":[{"name":"message","kind":"param","id":"message"}],"kind":"method","isPrivate":true,"id":"_add1()","line":"72"},{"returnType":{"name":"void","refId":"void"},"name":"close","kind":"method","comment":"\nClose the stream from the receiving end.\n\nClosing an already closed port has no effect.\n","id":"close0()","line":"86"},{"returnType":{"name":"StreamSubscription","refId":"dart.async/StreamSubscription"},"name":"listen","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"onData","kind":"param","id":"onData"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"name":"onError","kind":"param","id":"onError","line":"95"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"name":"onDone","kind":"param","id":"onDone","line":"96"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"unsubscribeOnError","kind":"param","id":"unsubscribeOnError","line":"97"}],"kind":"method","id":"listen4()","line":"94"},{"name":"_unmangleMessage","children":[{"name":"message","kind":"param","id":"message"}],"kind":"method","isPrivate":true,"id":"_unmangleMessage1()","line":"104"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"_isClosed","kind":"variable","isPrivate":true,"id":"_isClosed","line":"53"},{"isFinal":true,"ref":{"name":"ReceivePort","refId":"dart.isolate/ReceivePort"},"name":"_port","kind":"variable","isPrivate":true,"id":"_port","line":"54"},{"ref":{"name":"StreamController","refId":"dart.async/StreamController"},"name":"_controller","kind":"variable","isPrivate":true,"id":"_controller","line":"55"},{"name":"IsolateStream._fromOriginalReceivePort","children":[{"ref":{"name":"ReceivePort","refId":"dart.isolate/ReceivePort"},"name":"_port","kind":"param","isPrivate":true,"id":"_port"}],"kind":"constructor","isPrivate":true,"id":"IsolateStream._fromOriginalReceivePort1()","line":"57"},{"name":"IsolateStream._fromOriginalReceivePortOneShot","children":[{"ref":{"name":"ReceivePort","refId":"dart.isolate/ReceivePort"},"name":"_port","kind":"param","isPrivate":true,"id":"_port"}],"kind":"constructor","isPrivate":true,"id":"IsolateStream._fromOriginalReceivePortOneShot1()","line":"64"}],"uri":"sdk/lib/isolate/isolate_stream.dart","kind":"class","comment":"\n[IsolateStream]s, together with [IsolateSink]s, are the only means of\ncommunication between isolates. Each IsolateStream has a corresponding\n[IsolateSink]. Any message written into that sink will be delivered to\nthe stream and then dispatched to the stream's subscribers.\n","id":"IsolateStream","line":"52"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"MessageBox","children":[{"isFinal":true,"ref":{"name":"IsolateStream","refId":"dart.isolate/IsolateStream"},"name":"stream","kind":"variable","id":"stream","line":"23"},{"isFinal":true,"ref":{"name":"IsolateSink","refId":"dart.isolate/IsolateSink"},"name":"sink","kind":"variable","id":"sink","line":"24"},{"name":"MessageBox.oneShot","kind":"constructor","id":"MessageBox.oneShot0()","line":"26"},{"name":"MessageBox._oneShot","children":[{"ref":{"name":"ReceivePort","refId":"dart.isolate/ReceivePort"},"name":"receivePort","kind":"param","id":"receivePort"}],"kind":"constructor","isPrivate":true,"id":"MessageBox._oneShot1()","line":"27"},{"name":"MessageBox","kind":"constructor","id":"MessageBox0()","line":"31"},{"name":"MessageBox._","children":[{"ref":{"name":"ReceivePort","refId":"dart.isolate/ReceivePort"},"name":"receivePort","kind":"param","id":"receivePort"}],"kind":"constructor","isPrivate":true,"id":"MessageBox._1()","line":"32"}],"uri":"sdk/lib/isolate/isolate_stream.dart","kind":"class","comment":"\nA [MessageBox] creates an [IsolateStream], [stream], and an [IsolateSink],\n[sink].\n\nAny message that is written into the [sink] (independent of the isolate) is\nsent to the [stream] where its subscribers can react to the messages.\n","id":"MessageBox","line":"22"},{"interfaces":[{"name":"Exception","refId":"dart.core/Exception"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"IsolateUnhandledException","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"name":"toString","kind":"method","id":"toString0()","line":"176"},{"isFinal":true,"name":"message","kind":"variable","id":"message","line":"166"},{"isFinal":true,"name":"source","kind":"variable","id":"source","line":"169"},{"isFinal":true,"ref":{"name":"Object","refId":"dart.core/Object"},"name":"stackTrace","kind":"variable","id":"stackTrace","line":"172"},{"name":"IsolateUnhandledException","children":[{"name":"message","kind":"param","id":"message"},{"name":"source","kind":"param","id":"source"},{"ref":{"name":"Object","refId":"dart.core/Object"},"name":"stackTrace","kind":"param","id":"stackTrace"}],"kind":"constructor","id":"IsolateUnhandledException3()","line":"174"}],"uri":"sdk/lib/isolate/base.dart","kind":"class","comment":"\nWraps unhandled exceptions thrown during isolate execution. It is\nused to show both the error message and the stack trace for unhandled\nexceptions.\n","id":"IsolateUnhandledException","line":"164"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"name":"SendPortSync","children":[{"name":"callSync","children":[{"name":"message","kind":"param","id":"message"}],"kind":"method","id":"callSync1()","line":"145"}],"uri":"sdk/lib/isolate/base.dart","kind":"class","id":"SendPortSync","line":"143"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"name":"ReceivePort","children":[{"returnType":{"name":"void","refId":"void"},"name":"receive","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"name":"callback","kind":"param","id":"callback"}],"kind":"method","comment":"\nSets up a callback function for receiving pending or future\nmessages on this receive port.\n","id":"receive1()","line":"123"},{"returnType":{"name":"void","refId":"void"},"name":"close","kind":"method","comment":"\nCloses this receive port immediately. Pending messages will not\nbe processed and it is impossible to re-open the port. Single-shot\nreply ports, such as those created through [SendPort.call], are\nautomatically closed when the reply has been received. Multiple\ninvocations of [close] are allowed but ignored.\n","id":"close0()","line":"132"},{"returnType":{"name":"SendPort","refId":"dart.isolate/SendPort"},"name":"toSendPort","kind":"method","comment":"\nCreates a new send port that sends to this receive port. It is legal to\ncreate several [SendPort]s from the same [ReceivePort].\n","id":"toSendPort0()","line":"138"},{"name":"ReceivePort","kind":"constructor","comment":"\nOpens a long-lived port for receiving messages. The returned port\nmust be explicitly closed through [ReceivePort.close].\n","id":"ReceivePort0()","line":"117"}],"uri":"sdk/lib/isolate/base.dart","kind":"class","comment":"\n[ReceivePort]s, together with [SendPort]s, are the only means of\ncommunication between isolates. [ReceivePort]s have a [:toSendPort:] method\nwhich returns a [SendPort]. Any message that is sent through this [SendPort]\nis delivered to the [ReceivePort] it has been created from. There, they are\ndispatched to the callback that has been registered on the receive port.\n\nA [ReceivePort] may have many [SendPort]s.\n","id":"ReceivePort","line":"111"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"name":"SendPort","children":[{"returnType":{"name":"void","refId":"void"},"name":"send","children":[{"name":"message","kind":"param","id":"message"},{"ref":{"name":"SendPort","refId":"dart.isolate/SendPort"},"isOptional":true,"name":"replyTo","kind":"param","id":"replyTo"}],"kind":"method","comment":"\nSends an asynchronous [message] to this send port. The message is copied to\nthe receiving isolate. If specified, the [replyTo] port will be provided to\nthe receiver to facilitate exchanging sequences of messages.\n\nThe content of [message] can be: primitive values (null, num, bool, double,\nString), instances of [SendPort], and lists and maps whose elements are any\nof these. List and maps are also allowed to be cyclic.\n\nIn the special circumstances when two isolates share the same code and are\nrunning in the same process (e.g. isolates created via [spawnFunction]), it\nis also possible to send object instances (which would be copied in the\nprocess). This is currently only supported by the dartvm.  For now, the\ndart2js compiler only supports the restricted messages described above.\n\nDeprecation note: it is no longer valid to transmit a [ReceivePort] in a\nmessage. Previously they were translated to the corresponding send port\nbefore being transmitted.\n","id":"send2()","line":"77"},{"returnType":{"name":"Future","refId":"dart.async/Future"},"name":"call","children":[{"name":"message","kind":"param","id":"message"}],"kind":"method","comment":"\nSends a message to this send port and returns a [Future] of the reply.\nBasically, this internally creates a new receive port, sends a\nmessage to this send port with replyTo set to such receive port, and, when\na reply is received, it closes the receive port and completes the returned\nfuture.\n","id":"call1()","line":"86"},{"isOperator":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"==","children":[{"name":"other","kind":"param","id":"other"}],"kind":"method","comment":"\nTests whether [other] is a [SendPort] pointing to the same\n[ReceivePort] as this one.\n","id":"==1()","line":"92"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"hashCode","kind":"property","comment":"\nReturns an immutable hash code for this send port that is\nconsistent with the == operator.\n","id":"hashCode","line":"98"}],"uri":"sdk/lib/isolate/base.dart","kind":"class","comment":"\n[SendPort]s are created from [ReceivePort]s. Any message sent through\na [SendPort] is delivered to its respective [ReceivePort]. There might be\nmany [SendPort]s for the same [ReceivePort].\n\n[SendPort]s can be transmitted to other isolates.\n","id":"SendPort","line":"56"},{"interfaces":[{"name":"Exception","refId":"dart.core/Exception"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"IsolateSpawnException","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"name":"toString","kind":"method","id":"toString0()","line":"9"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"name":"_s","kind":"variable","isPrivate":true,"id":"_s","line":"10"},{"name":"IsolateSpawnException","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"_s","kind":"param","isPrivate":true,"id":"_s"}],"kind":"constructor","id":"IsolateSpawnException1()","line":"8"}],"uri":"sdk/lib/isolate/base.dart","kind":"class","id":"IsolateSpawnException","line":"7"}],"uri":"sdk/lib/isolate/isolate.dart","kind":"library","id":"dart.isolate","line":"5"}
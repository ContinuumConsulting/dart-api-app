{"name":"mock","children":[{"returnType":{"name":"Matcher","refId":"matcher/Matcher"},"name":"neverThrew","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"\n[neverThrew] asserts that no matching call to a method threw\na value that matched [value].\n","id":"neverThrew1()","line":"1198"},{"returnType":{"name":"Matcher","refId":"matcher/Matcher"},"name":"sometimeThrew","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"\n[sometimeThrew] asserts that at least one matching call to a method threw\na value that matched [value].\n","id":"sometimeThrew1()","line":"1191"},{"returnType":{"name":"Matcher","refId":"matcher/Matcher"},"name":"alwaysThrew","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"\n[alwaysThrew] asserts that all matching calls to a method threw\na value that matched [value].\n","id":"alwaysThrew1()","line":"1184"},{"returnType":{"name":"Matcher","refId":"matcher/Matcher"},"name":"neverReturned","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"\n[neverReturned] asserts that no matching calls to a method returned\na value that matched [value].\n","id":"neverReturned1()","line":"1177"},{"returnType":{"name":"Matcher","refId":"matcher/Matcher"},"name":"sometimeReturned","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"\n[sometimeReturned] asserts that at least one matching call to a method\nreturned a value that matched [value].\n","id":"sometimeReturned1()","line":"1170"},{"returnType":{"name":"Matcher","refId":"matcher/Matcher"},"name":"alwaysReturned","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"\n[alwaysReturned] asserts that all matching calls to a method returned\na value that matched [value].\n","id":"alwaysReturned1()","line":"1163"},{"returnType":{"name":"Matcher","refId":"matcher/Matcher"},"name":"throwing","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"\n[throwing] matches log entrues where the call to a method threw\na value that matched [value].\n","id":"throwing1()","line":"1058"},{"returnType":{"name":"Matcher","refId":"matcher/Matcher"},"name":"returning","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"\n[returning] matches log entries where the call to a method returned\na value that matched [value].\n","id":"returning1()","line":"1051"},{"returnType":{"name":"Matcher","refId":"matcher/Matcher"},"name":"happenedAtMost","children":[{"name":"count","kind":"param","id":"count"}],"kind":"method","comment":"[happenedAtMost] matches a maximum number of calls. ","id":"happenedAtMost1()","line":"988"},{"returnType":{"name":"Matcher","refId":"matcher/Matcher"},"name":"happenedAtLeast","children":[{"name":"count","kind":"param","id":"count"}],"kind":"method","comment":"[happenedAtLeast] matches a minimum number of calls. ","id":"happenedAtLeast1()","line":"983"},{"returnType":{"name":"Matcher","refId":"matcher/Matcher"},"name":"happenedExactly","children":[{"name":"count","kind":"param","id":"count"}],"kind":"method","comment":"[happenedExactly] matches an exact number of calls. ","id":"happenedExactly1()","line":"978"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"_qualifiedName","children":[{"name":"owner","kind":"param","id":"owner"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"method","kind":"param","id":"method"}],"kind":"method","isPrivate":true,"comment":"Utility function for optionally qualified method names ","id":"_qualifiedName2()","line":"419"},{"returnType":{"name":"CallMatcher","refId":"mock/CallMatcher"},"name":"callsTo","children":[{"isOptional":true,"name":"method","kind":"param","id":"method"},{"isOptional":true,"name":"arg0","kind":"param","id":"arg0","line":"274"},{"isOptional":true,"name":"arg1","kind":"param","id":"arg1","line":"275"},{"isOptional":true,"name":"arg2","kind":"param","id":"arg2","line":"276"},{"isOptional":true,"name":"arg3","kind":"param","id":"arg3","line":"277"},{"isOptional":true,"name":"arg4","kind":"param","id":"arg4","line":"278"},{"isOptional":true,"name":"arg5","kind":"param","id":"arg5","line":"279"},{"isOptional":true,"name":"arg6","kind":"param","id":"arg6","line":"280"},{"isOptional":true,"name":"arg7","kind":"param","id":"arg7","line":"281"},{"isOptional":true,"name":"arg8","kind":"param","id":"arg8","line":"282"},{"isOptional":true,"name":"arg9","kind":"param","id":"arg9","line":"283"}],"kind":"method","comment":"\nReturns a [CallMatcher] for the specified signature. [method] can be\nnull to match anything, or a literal [String], a predicate [Function],\nor a [Matcher]. The various arguments can be scalar values or [Matcher]s.\n","id":"callsTo11()","line":"273"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"_mockingErrorFormatter","children":[{"name":"actual","kind":"param","id":"actual"},{"ref":{"name":"Matcher","refId":"matcher/Matcher"},"name":"matcher","kind":"param","id":"matcher"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"signature","kind":"param","id":"signature"},{"ref":{"name":"MatchState","refId":"matcher/MatchState"},"name":"matchState","kind":"param","id":"matchState","line":"99"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"verbose","kind":"param","id":"verbose","line":"99"}],"kind":"method","isPrivate":true,"comment":"\nThe error formatter for mocking is a bit different from the default one\nfor unit testing; instead of the third argument being a 'reason'\nit is instead a [signature] describing the method signature filter\nthat was used to select the logs that were verified.\n","id":"_mockingErrorFormatter5()","line":"98"},{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"sharedLog","kind":"variable","id":"sharedLog","line":"1202"},{"ref":{"name":"Matcher","refId":"matcher/Matcher"},"name":"happenedAtMostOnce","kind":"variable","id":"happenedAtMostOnce","line":"1002"},{"ref":{"name":"Matcher","refId":"matcher/Matcher"},"name":"happenedAtLeastOnce","kind":"variable","id":"happenedAtLeastOnce","line":"999"},{"ref":{"name":"Matcher","refId":"matcher/Matcher"},"name":"happenedOnce","kind":"variable","id":"happenedOnce","line":"996"},{"ref":{"name":"Matcher","refId":"matcher/Matcher"},"name":"neverHappened","kind":"variable","id":"neverHappened","line":"993"},{"name":"_noArg","kind":"variable","isPrivate":true,"id":"_noArg","line":"132"},{"ref":{"name":"_MockFailureHandler","refId":"mock/_MockFailureHandler"},"name":"_mockFailureHandler","kind":"variable","isPrivate":true,"id":"_mockFailureHandler","line":"126"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Mock","children":[{"isSetter":true,"name":"logging=","children":[{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"value","kind":"param","id":"value"}],"kind":"method","id":"logging=1()","line":"1222"},{"returnType":{"name":"Behavior","refId":"mock/Behavior"},"name":"when","children":[{"ref":{"name":"CallMatcher","refId":"mock/CallMatcher"},"name":"logFilter","kind":"param","id":"logFilter"}],"kind":"method","comment":"\n[when] is used to create a new or extend an existing [Behavior].\nA [CallMatcher] [filter] must be supplied, and the [Behavior]s for\nthat signature are returned (being created first if needed).\n\nTypical use case:\n\n    mock.when(callsTo(...)).alwaysReturn(...);\n","id":"when1()","line":"1266"},{"name":"noSuchMethod","children":[{"ref":{"name":"InvocationMirror","refId":"dart.core/InvocationMirror"},"name":"invocation","kind":"param","id":"invocation"}],"kind":"method","comment":"\nThis is the handler for method calls. We loop through the list\nof [Behavior]s, and find the first match that still has return\nvalues available, and then do the action specified by that\nreturn value. If we find no [Behavior] to apply an exception is\nthrown.\n","id":"noSuchMethod1()","line":"1284"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"verifyZeroInteractions","kind":"method","comment":"[verifyZeroInteractions] returns true if no calls were made ","id":"verifyZeroInteractions0()","line":"1399"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"getLogs","children":[{"ref":{"name":"CallMatcher","refId":"mock/CallMatcher"},"isOptional":true,"name":"logFilter","kind":"param","id":"logFilter"},{"ref":{"name":"Matcher","refId":"matcher/Matcher"},"isOptional":true,"name":"actionMatcher","kind":"param","id":"actionMatcher","line":"1425"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"destructive","kind":"param","id":"destructive","line":"1426"}],"kind":"method","comment":"\n[getLogs] extracts all calls from the call log that match the\n[logFilter], and returns the matching list of [LogEntry]s. If\n[destructive] is false (the default) the matching calls are left\nin the log, else they are removed. Removal allows us to verify a\nset of interactions and then verify that there are no other\ninteractions left. [actionMatcher] can be used to further\nrestrict the returned logs based on the action the mock performed.\n[logFilter] can be a [CallMatcher] or a predicate function that\ntakes a [LogEntry] and returns a bool.\n\nTypical usage:\n\n    getLogs(callsTo(...)).verify(...);\n","id":"getLogs3()","line":"1424"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"calls","children":[{"name":"method","kind":"param","id":"method"},{"isOptional":true,"name":"arg0","kind":"param","id":"arg0","line":"1442"},{"isOptional":true,"name":"arg1","kind":"param","id":"arg1","line":"1443"},{"isOptional":true,"name":"arg2","kind":"param","id":"arg2","line":"1444"},{"isOptional":true,"name":"arg3","kind":"param","id":"arg3","line":"1445"},{"isOptional":true,"name":"arg4","kind":"param","id":"arg4","line":"1446"},{"isOptional":true,"name":"arg5","kind":"param","id":"arg5","line":"1447"},{"isOptional":true,"name":"arg6","kind":"param","id":"arg6","line":"1448"},{"isOptional":true,"name":"arg7","kind":"param","id":"arg7","line":"1449"},{"isOptional":true,"name":"arg8","kind":"param","id":"arg8","line":"1450"},{"isOptional":true,"name":"arg9","kind":"param","id":"arg9","line":"1451"}],"kind":"method","comment":"\nUseful shorthand method that creates a [CallMatcher] from its arguments\nand then calls [getLogs].\n","id":"calls11()","line":"1441"},{"returnType":{"name":"void","refId":"void"},"name":"resetBehavior","kind":"method","comment":"Clear the behaviors for the Mock. ","id":"resetBehavior0()","line":"1456"},{"returnType":{"name":"void","refId":"void"},"name":"clearLogs","kind":"method","comment":"Clear the logs for the Mock. ","id":"clearLogs0()","line":"1459"},{"returnType":{"name":"void","refId":"void"},"name":"reset","kind":"method","comment":"Clear both logs and behavior. ","id":"reset0()","line":"1470"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"logging","kind":"property","id":"logging","line":"1221"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"name":"name","kind":"variable","id":"name","line":"1207"},{"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"},{"name":"Behavior","refId":"mock/Behavior"}]},"name":"_behaviors","kind":"variable","isPrivate":true,"id":"_behaviors","line":"1210"},{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"log","kind":"variable","id":"log","line":"1213"},{"isFinal":true,"ref":{"name":"bool","refId":"dart.core/bool"},"name":"_throwIfNoBehavior","kind":"variable","isPrivate":true,"id":"_throwIfNoBehavior","line":"1216"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"_logging","kind":"variable","isPrivate":true,"id":"_logging","line":"1219"},{"name":"Mock","kind":"constructor","comment":"\nDefault constructor. Unknown method calls are allowed and logged,\nthe mock has no name, and has its own log.\n","id":"Mock0()","line":"1233"},{"name":"Mock.custom","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"name":"name","kind":"param","id":"name"},{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"isOptional":true,"name":"log","kind":"param","id":"log","line":"1247"},{"isOptional":true,"name":"throwIfNoBehavior","kind":"param","id":"throwIfNoBehavior","line":"1248"},{"isOptional":true,"name":"enableLogging","kind":"param","id":"enableLogging","line":"1249"}],"kind":"constructor","comment":"\nThis constructor makes a mock that has a [name] and possibly uses\na shared [log]. If [throwIfNoBehavior] is true, any calls to methods\nthat have no defined behaviors will throw an exception; otherwise they\nwill be allowed and logged (but will not do anything).\nIf [enableLogging] is false, no logging will be done initially (whether\nor not a [log] is supplied), but [logging] can be set to true later.\n","id":"Mock.custom4()","line":"1246"}],"kind":"class","comment":"The base class for all mocked objects. ","id":"Mock","line":"1205"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"LogEntryList","children":[{"name":"add","children":[{"ref":{"name":"LogEntry","refId":"mock/LogEntry"},"name":"entry","kind":"param","id":"entry"}],"kind":"method","comment":"Add a [LogEntry] to the log. ","id":"add1()","line":"455"},{"returnType":{"name":"Function","refId":"dart.core/Function"},"name":"_makePredicate","children":[{"name":"arg","kind":"param","id":"arg"}],"kind":"method","isPrivate":true,"comment":"Creates a LogEntry predicate function from the argument. ","id":"_makePredicate1()","line":"464"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"getMatches","children":[{"isOptional":true,"name":"mockNameFilter","kind":"param","id":"mockNameFilter"},{"isOptional":true,"name":"logFilter","kind":"param","id":"logFilter","line":"489"},{"ref":{"name":"Matcher","refId":"matcher/Matcher"},"isOptional":true,"name":"actionMatcher","kind":"param","id":"actionMatcher","line":"490"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"destructive","kind":"param","id":"destructive","line":"491"}],"kind":"method","comment":"\nCreate a new [LogEntryList] consisting of [LogEntry]s from\nthis list that match the specified [mockNameFilter] and [logFilter].\n[mockNameFilter] can be null, a [String], a predicate [Function],\nor a [Matcher]. If [mockNameFilter] is null, this is the same as\n[anything].\nIf [logFilter] is null, all entries in the log will be returned.\nOtherwise [logFilter] should be a [CallMatcher] or  predicate function\nthat takes a [LogEntry] and returns a bool.\nIf [destructive] is true, the log entries are removed from the\noriginal list.\n","id":"getMatches4()","line":"488"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"verify","children":[{"ref":{"name":"Matcher","refId":"matcher/Matcher"},"name":"matcher","kind":"param","id":"matcher"}],"kind":"method","comment":"Apply a unit test [Matcher] to the [LogEntryList]. ","id":"verify1()","line":"518"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"stepwiseValidate","children":[{"ref":{"name":"StepValidator","refId":"mock/StepValidator"},"name":"validator","kind":"param","id":"validator"},{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"name":"reason","kind":"param","id":"reason"}],"kind":"method","comment":"\nIterate through the list and call the [validator] function with the\nlog [List] and position. The [validator] should return the number of\npositions to advance upon success, or zero upon failure. When zero is\nreturned an error is reported. [reason] can be used to provide a\nmore descriptive failure message. If a failure occurred false will be\nreturned (unless the failure handler itself threw an exception);\notherwise true is returned.\nThe use case here is to perform more complex validations; for example\nwe may want to assert that the return value from some function is\nlater used as a parameter to a following function. If we filter the logs\nto include just these two functions we can write a simple validator to\ndo this check.\n","id":"stepwiseValidate2()","line":"541"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"toString","children":[{"ref":{"name":"Date","refId":"dart.core/Date"},"isOptional":true,"name":"baseTime","kind":"param","id":"baseTime"}],"kind":"method","comment":"\nTurn the logs into human-readable text. If [baseTime] is specified\nthen each entry is prefixed with the offset from that time in\nmilliseconds; otherwise the time of day is used.\n","id":"toString1()","line":"568"},{"returnType":{"name":"int","refId":"dart.core/int"},"name":"findLogEntry","children":[{"name":"logFilter","kind":"param","id":"logFilter"},{"ref":{"name":"int","refId":"dart.core/int"},"isOptional":true,"name":"start","kind":"param","id":"start"},{"ref":{"name":"int","refId":"dart.core/int"},"isOptional":true,"name":"failureReturnValue","kind":"param","id":"failureReturnValue"},{"isOptional":true,"name":"skip","kind":"param","id":"skip","line":"588"}],"kind":"method","comment":"\n Find the first log entry that satisfies [logFilter] and\n return its position. A search [start] position can be provided\n to allow for repeated searches. [logFilter] can be a [CallMatcher],\n or a predicate function that takes a [LogEntry] argument and returns\n a bool. If [logFilter] is null, it will match any [LogEntry].\n If no entry is found, then [failureReturnValue] is returned.\n After each check the position is updated by [skip], so using\n [skip] of -1 allows backward searches, using a [skip] of 2 can\n be used to check pairs of adjacent entries, and so on.\n","id":"findLogEntry4()","line":"587"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"_head","children":[{"name":"logFilter","kind":"param","id":"logFilter"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"inPlace","kind":"param","id":"inPlace"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"description","kind":"param","id":"description","line":"610"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"defaultPosition","kind":"param","id":"defaultPosition","line":"610"}],"kind":"method","isPrivate":true,"comment":"\nReturns log events that happened up to the first one that\nsatisfies [logFilter]. If [inPlace] is true, then returns\nthis LogEntryList after removing the from the first satisfier;\nonwards otherwise a new list is created. [description]\nis used to create a new name for the resulting list.\n[defaultPosition] is used as the index of the matching item in\nthe case that no match is found.\n","id":"_head4()","line":"609"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"_tail","children":[{"name":"logFilter","kind":"param","id":"logFilter"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"inPlace","kind":"param","id":"inPlace"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"description","kind":"param","id":"description","line":"640"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"defaultPosition","kind":"param","id":"defaultPosition","line":"640"}],"kind":"method","isPrivate":true,"comment":"\nReturns log events that happened from the first one that\nsatisfies [logFilter]. If [inPlace] is true, then returns\nthis LogEntryList after removing the entries up to the first\nsatisfier; otherwise a new list is created. [description]\nis used to create a new name for the resulting list.\n[defaultPosition] is used as the index of the matching item in\nthe case that no match is found.\n","id":"_tail4()","line":"639"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"after","children":[{"ref":{"name":"Date","refId":"dart.core/Date"},"name":"when","kind":"param","id":"when"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened after [when]. If [inPlace]\nis true, then it returns this LogEntryList after removing\nthe entries that happened up to [when]; otherwise a new\nlist is created.\n","id":"after2()","line":"666"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"from","children":[{"ref":{"name":"Date","refId":"dart.core/Date"},"name":"when","kind":"param","id":"when"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened from [when] onwards. If\n[inPlace] is true, then it returns this LogEntryList after\nremoving the entries that happened before [when]; otherwise\na new list is created.\n","id":"from2()","line":"675"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"until","children":[{"ref":{"name":"Date","refId":"dart.core/Date"},"name":"when","kind":"param","id":"when"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened until [when]. If [inPlace]\nis true, then it returns this LogEntryList after removing\nthe entries that happened after [when]; otherwise a new\nlist is created.\n","id":"until2()","line":"684"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"before","children":[{"ref":{"name":"Date","refId":"dart.core/Date"},"name":"when","kind":"param","id":"when"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened before [when]. If [inPlace]\nis true, then it returns this LogEntryList after removing\nthe entries that happened from [when] onwards; otherwise a new\nlist is created.\n","id":"before2()","line":"693"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"afterEntry","children":[{"ref":{"name":"LogEntry","refId":"mock/LogEntry"},"name":"logEntry","kind":"param","id":"logEntry"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened after [logEntry]'s time.\nIf [inPlace] is true, then it returns this LogEntryList after\nremoving the entries that happened up to [when]; otherwise a new\nlist is created. If [logEntry] is null the current time is used.\n","id":"afterEntry2()","line":"702"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"fromEntry","children":[{"ref":{"name":"LogEntry","refId":"mock/LogEntry"},"name":"logEntry","kind":"param","id":"logEntry"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened from [logEntry]'s time onwards.\nIf [inPlace] is true, then it returns this LogEntryList after\nremoving the entries that happened before [when]; otherwise\na new list is created. If [logEntry] is null the current time is used.\n","id":"fromEntry2()","line":"711"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"untilEntry","children":[{"ref":{"name":"LogEntry","refId":"mock/LogEntry"},"name":"logEntry","kind":"param","id":"logEntry"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened until [logEntry]'s time. If\n[inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened after [when]; otherwise a new\nlist is created. If [logEntry] is null the epoch time is used.\n","id":"untilEntry2()","line":"720"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"beforeEntry","children":[{"ref":{"name":"LogEntry","refId":"mock/LogEntry"},"name":"logEntry","kind":"param","id":"logEntry"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened before [logEntry]'s time. If\n[inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened from [when] onwards; otherwise a new\nlist is created. If [logEntry] is null the epoch time is used.\n","id":"beforeEntry2()","line":"730"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"afterFirst","children":[{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"segment","kind":"param","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened after the first event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened earlier; otherwise a new list is created.\n","id":"afterFirst2()","line":"739"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"afterLast","children":[{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"segment","kind":"param","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened after the last event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened earlier; otherwise a new list is created.\n","id":"afterLast2()","line":"747"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"fromFirst","children":[{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"segment","kind":"param","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened from the time of the first event in\n[segment] onwards. If [inPlace] is true, then it returns this\nLogEntryList after removing the earlier entries; otherwise a new list\nis created.\n","id":"fromFirst2()","line":"756"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"fromLast","children":[{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"segment","kind":"param","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened from the time of the last event in\n[segment] onwards. If [inPlace] is true, then it returns this\nLogEntryList after removing the earlier entries; otherwise a new list\nis created.\n","id":"fromLast2()","line":"765"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"untilFirst","children":[{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"segment","kind":"param","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened until the first event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n","id":"untilFirst2()","line":"773"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"untilLast","children":[{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"segment","kind":"param","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened until the last event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n","id":"untilLast2()","line":"781"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"beforeFirst","children":[{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"segment","kind":"param","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened before the first event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n","id":"beforeFirst2()","line":"789"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"beforeLast","children":[{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"segment","kind":"param","id":"segment"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"inPlace","kind":"param","id":"inPlace"}],"kind":"method","comment":"\nReturns log events that happened before the last event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n","id":"beforeLast2()","line":"797"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"_neighboring","children":[{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"isPreceding","kind":"param","id":"isPreceding"},{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"keys","kind":"param","id":"keys","line":"811"},{"name":"mockNameFilter","kind":"param","id":"mockNameFilter","line":"812"},{"name":"logFilter","kind":"param","id":"logFilter","line":"813"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"distance","kind":"param","id":"distance","line":"814"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"includeKeys","kind":"param","id":"includeKeys","line":"815"}],"kind":"method","isPrivate":true,"comment":"\nIterate through the LogEntryList looking for matches to the entries\nin [keys]; for each match found the closest [distance] neighboring log\nentries that match [mockNameFilter] and [logFilter] will be included in\nthe result. If [isPreceding] is true we use the neighbors that precede\nthe matched entry; else we use the neighbors that followed.\nIf [includeKeys] is true then the entries in [keys] that resulted in\nentries in the output list are themselves included in the output list. If\n[distance] is zero then all matches are included.\n","id":"_neighboring6()","line":"810"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"preceding","children":[{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"keys","kind":"param","id":"keys"},{"isOptional":true,"name":"mockNameFilter","kind":"param","id":"mockNameFilter","line":"921"},{"isOptional":true,"name":"logFilter","kind":"param","id":"logFilter","line":"922"},{"ref":{"name":"int","refId":"dart.core/int"},"isOptional":true,"name":"distance","kind":"param","id":"distance","line":"923"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"includeKeys","kind":"param","id":"includeKeys","line":"924"}],"kind":"method","comment":"\nIterate through the LogEntryList looking for matches to the entries\nin [keys]; for each match found the closest [distance] prior log entries\nthat match [mocknameFilter] and [logFilter] will be included in the result.\nIf [includeKeys] is true then the entries in [keys] that resulted in\nentries in the output list are themselves included in the output list. If\n[distance] is zero then all matches are included.\n\nThe idea here is that you could find log entries that are related to\nother logs entries in some temporal sense. For example, say we have a\nmethod commit() that returns -1 on failure. Before commit() gets called\nthe value being committed is created by process(). We may want to find\nthe calls to process() that preceded calls to commit() that failed.\nWe could do this with:\n\n     print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),\n         logFilter: callsTo('process')).toString());\n\nWe might want to include the details of the failing calls to commit()\nto see what parameters were passed in, in which case we would set\n[includeKeys].\n\nAs another simple example, say we wanted to know the three method\ncalls that immediately preceded each failing call to commit():\n\n    print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),\n        distance: 3).toString());\n","id":"preceding5()","line":"920"},{"returnType":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"following","children":[{"ref":{"name":"LogEntryList","refId":"mock/LogEntryList"},"name":"keys","kind":"param","id":"keys"},{"isOptional":true,"name":"mockNameFilter","kind":"param","id":"mockNameFilter","line":"938"},{"isOptional":true,"name":"logFilter","kind":"param","id":"logFilter","line":"939"},{"ref":{"name":"int","refId":"dart.core/int"},"isOptional":true,"name":"distance","kind":"param","id":"distance","line":"940"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isOptional":true,"name":"includeKeys","kind":"param","id":"includeKeys","line":"941"}],"kind":"method","comment":"\nIterate through the LogEntryList looking for matches to the entries\nin [keys]; for each match found the closest [distance] subsequent log\nentries that match [mocknameFilter] and [logFilter] will be included in\nthe result. If [includeKeys] is true then the entries in [keys] that\nresulted in entries in the output list are themselves included in the\noutput list. If [distance] is zero then all matches are included.\nSee [preceding] for a usage example.\n","id":"following5()","line":"937"},{"name":"first","kind":"property","comment":"Get the first entry, or null if no entries. ","id":"first","line":"458"},{"name":"last","kind":"property","comment":"Get the last entry, or null if no entries. ","id":"last","line":"461"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"filter","kind":"variable","id":"filter","line":"448"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"LogEntry","refId":"mock/LogEntry"}]},"name":"logs","kind":"variable","id":"logs","line":"449"},{"name":"LogEntryList","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"name":"filter","kind":"param","id":"filter"}],"kind":"constructor","id":"LogEntryList1()","line":"450"}],"kind":"class","comment":"\nWe do verification on a list of [LogEntry]s. To allow chaining\nof calls to verify, we encapsulate such a list in the [LogEntryList]\nclass.\n","id":"LogEntryList","line":"447"},{"returnType":{"name":"int","refId":"dart.core/int"},"name":"StepValidator","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"LogEntry","refId":"mock/LogEntry"}]},"name":"logs","kind":"param","id":"logs"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"pos","kind":"param","id":"pos"}],"kind":"typedef","comment":"\n[StepValidator]s are used by [stepwiseValidate] in [LogEntryList], which\niterates through the list and call the [StepValidator] function with the\nlog [List] and position. The [StepValidator] should return the number of\npositions to advance upon success, or zero upon failure. When zero is\nreturned an error is reported.\n","id":"StepValidator","line":"440"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"LogEntry","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"name":"_pad2","children":[{"ref":{"name":"int","refId":"dart.core/int"},"name":"val","kind":"param","id":"val"}],"kind":"method","isPrivate":true,"id":"_pad21()","line":"390"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"toString","children":[{"ref":{"name":"Date","refId":"dart.core/Date"},"isOptional":true,"name":"baseTime","kind":"param","id":"baseTime"}],"kind":"method","id":"toString1()","line":"392"},{"ref":{"name":"Date","refId":"dart.core/Date"},"name":"time","kind":"variable","id":"time","line":"368"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"name":"mockName","kind":"variable","id":"mockName","line":"371"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"name":"methodName","kind":"variable","id":"methodName","line":"374"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List"},"name":"args","kind":"variable","id":"args","line":"377"},{"isFinal":true,"ref":{"name":"Action","refId":"mock/Action"},"name":"action","kind":"variable","id":"action","line":"380"},{"isFinal":true,"name":"value","kind":"variable","id":"value","line":"383"},{"name":"LogEntry","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"mockName","kind":"param","id":"mockName"},{"ref":{"name":"String","refId":"dart.core/String"},"name":"methodName","kind":"param","id":"methodName"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"args","kind":"param","id":"args","line":"386"},{"ref":{"name":"Action","refId":"mock/Action"},"name":"action","kind":"param","id":"action","line":"386"},{"isOptional":true,"name":"value","kind":"param","id":"value","line":"386"}],"kind":"constructor","id":"LogEntry5()","line":"385"}],"kind":"class","comment":"\nEvery call to a [Mock] object method is logged. The logs are\nkept in instances of [LogEntry].\n","id":"LogEntry","line":"366"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Behavior","children":[{"returnType":{"name":"Behavior","refId":"mock/Behavior"},"name":"thenReturn","children":[{"name":"value","kind":"param","id":"value"},{"isOptional":true,"name":"count","kind":"param","id":"count"}],"kind":"method","comment":"\nAdds a [Responder] that returns a [value] for [count] calls\n(1 by default).\n","id":"thenReturn2()","line":"305"},{"returnType":{"name":"Behavior","refId":"mock/Behavior"},"name":"alwaysReturn","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"Adds a [Responder] that repeatedly returns a [value]. ","id":"alwaysReturn1()","line":"311"},{"returnType":{"name":"Behavior","refId":"mock/Behavior"},"name":"thenThrow","children":[{"name":"value","kind":"param","id":"value"},{"isOptional":true,"name":"count","kind":"param","id":"count"}],"kind":"method","comment":"\nAdds a [Responder] that throws [value] [count]\ntimes (1 by default).\n","id":"thenThrow2()","line":"319"},{"returnType":{"name":"Behavior","refId":"mock/Behavior"},"name":"alwaysThrow","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"Adds a [Responder] that throws [value] endlessly. ","id":"alwaysThrow1()","line":"325"},{"returnType":{"name":"Behavior","refId":"mock/Behavior"},"name":"thenCall","children":[{"name":"value","kind":"param","id":"value"},{"isOptional":true,"name":"count","kind":"param","id":"count"}],"kind":"method","comment":"\n[thenCall] creates a proxy Responder, that is called [count]\ntimes (1 by default; 0 is used for unlimited calls, and is\nexposed as [alwaysCall]). [value] is the function that will\nbe called with the same arguments that were passed to the\nmock. Proxies can be used to wrap real objects or to define\nmore complex return/throw behavior. You could even (if you\nwanted) use proxies to emulate the behavior of thenReturn;\ne.g.:\n\n    m.when(callsTo('foo')).thenReturn(0)\n\nis equivalent to:\n\n    m.when(callsTo('foo')).thenCall(() => 0)\n","id":"thenCall2()","line":"345"},{"returnType":{"name":"Behavior","refId":"mock/Behavior"},"name":"alwaysCall","children":[{"name":"value","kind":"param","id":"value"}],"kind":"method","comment":"Creates a repeating proxy call. ","id":"alwaysCall1()","line":"351"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"matches","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"method","kind":"param","id":"method"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"args","kind":"param","id":"args"}],"kind":"method","comment":"Returns true if a method call matches the [Behavior]. ","id":"matches2()","line":"356"},{"returnType":{"name":"String","refId":"dart.core/String"},"name":"toString","kind":"method","comment":"Returns the [matcher]'s representation. ","id":"toString0()","line":"359"},{"ref":{"name":"CallMatcher","refId":"mock/CallMatcher"},"name":"matcher","kind":"variable","id":"matcher","line":"293"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Responder","refId":"mock/Responder"}]},"name":"actions","kind":"variable","id":"actions","line":"294"},{"ref":{"name":"bool","refId":"dart.core/bool"},"name":"logging","kind":"variable","id":"logging","line":"295"},{"name":"Behavior","children":[{"ref":{"name":"CallMatcher","refId":"mock/CallMatcher"},"name":"matcher","kind":"param","id":"matcher"}],"kind":"constructor","id":"Behavior1()","line":"297"}],"kind":"class","comment":"\nA [Behavior] represents how a [Mock] will respond to one particular\ntype of method call.\n","id":"Behavior","line":"292"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"CallMatcher","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"name":"toString","kind":"method","comment":"\nWe keep our behavior specifications in a Map, which is keyed\nby the [CallMatcher]. To make the keys unique and to get a\ndescriptive value for the [CallMatcher] we have this override\nof [toString()].\n","id":"toString0()","line":"229"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"name":"matches","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"method","kind":"param","id":"method"},{"ref":{"name":"List","refId":"dart.core/List"},"name":"arguments","kind":"param","id":"arguments"}],"kind":"method","comment":"\nGiven a [method] name and list of [arguments], return true\nif it matches this [CallMatcher.\n","id":"matches2()","line":"250"},{"ref":{"name":"Matcher","refId":"matcher/Matcher"},"name":"nameFilter","kind":"variable","id":"nameFilter","line":"175"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Matcher","refId":"matcher/Matcher"}]},"name":"argMatchers","kind":"variable","id":"argMatchers","line":"176"},{"name":"CallMatcher","children":[{"isOptional":true,"name":"name","kind":"param","id":"name"},{"isOptional":true,"name":"arg0","kind":"param","id":"arg0","line":"185"},{"isOptional":true,"name":"arg1","kind":"param","id":"arg1","line":"186"},{"isOptional":true,"name":"arg2","kind":"param","id":"arg2","line":"187"},{"isOptional":true,"name":"arg3","kind":"param","id":"arg3","line":"188"},{"isOptional":true,"name":"arg4","kind":"param","id":"arg4","line":"189"},{"isOptional":true,"name":"arg5","kind":"param","id":"arg5","line":"190"},{"isOptional":true,"name":"arg6","kind":"param","id":"arg6","line":"191"},{"isOptional":true,"name":"arg7","kind":"param","id":"arg7","line":"192"},{"isOptional":true,"name":"arg8","kind":"param","id":"arg8","line":"193"},{"isOptional":true,"name":"arg9","kind":"param","id":"arg9","line":"194"}],"kind":"constructor","comment":"\nConstructor for [CallMatcher]. [name] can be null to\nmatch anything, or a literal [String], a predicate [Function],\nor a [Matcher]. The various arguments can be scalar values or\n[Matcher]s.\n","id":"CallMatcher11()","line":"184"}],"kind":"class","comment":"\nA [CallMatcher] is a special matcher used to match method calls (i.e.\na method name and set of arguments). It is not a [Matcher] like the\nunit test [Matcher], but instead represents a method name and a\ncollection of [Matcher]s, one per argument, that will be applied\nto the parameters to decide if the method call is a match.\n","id":"CallMatcher","line":"174"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Responder","children":[{"name":"value","kind":"variable","id":"value","line":"161"},{"ref":{"name":"Action","refId":"mock/Action"},"name":"action","kind":"variable","id":"action","line":"162"},{"ref":{"name":"int","refId":"dart.core/int"},"name":"count","kind":"variable","id":"count","line":"163"},{"name":"Responder","children":[{"name":"value","kind":"param","id":"value"},{"ref":{"name":"int","refId":"dart.core/int"},"isOptional":true,"name":"count","kind":"param","id":"count"},{"ref":{"name":"Action","refId":"mock/Action"},"isOptional":true,"name":"action","kind":"param","id":"action"}],"kind":"constructor","id":"Responder3()","line":"164"}],"kind":"class","comment":"\nThe behavior of a method call in the mock library is specified\nwith [Responder]s. A [Responder] has a [value] to throw\nor return (depending on the type of [action]),\nand can either be one-shot, multi-shot, or infinitely repeating,\ndepending on the value of [count (1, greater than 1, or 0 respectively).\n","id":"Responder","line":"160"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"name":"Action","children":[{"isStatic":true,"name":"IGNORE","kind":"variable","id":"IGNORE","line":"137"},{"isStatic":true,"name":"RETURN","kind":"variable","id":"RETURN","line":"140"},{"isStatic":true,"name":"THROW","kind":"variable","id":"THROW","line":"143"},{"isStatic":true,"name":"PROXY","kind":"variable","id":"PROXY","line":"146"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"name":"name","kind":"variable","id":"name","line":"150"},{"name":"Action._","children":[{"ref":{"name":"String","refId":"dart.core/String"},"name":"name","kind":"param","id":"name"}],"kind":"constructor","isPrivate":true,"id":"Action._1()","line":"148"}],"kind":"class","comment":"The ways in which a call to a mock method can be handled. ","id":"Action","line":"135"}],"uri":"pkg/unittest/lib/mock.dart","kind":"library","comment":"\nA simple mocking/spy library.\n\nTo create a mock objects for some class T, create a new class using:\n\n    class MockT extends Mock implements T {};\n\nThen specify the [Behavior] of the Mock for different methods using\n[when] (to select the method and parameters) and then the [Action]s\nfor the [Behavior] by calling [thenReturn], [alwaysReturn], [thenThrow],\n[alwaysThrow], [thenCall] or [alwaysCall].\n\n[thenReturn], [thenThrow] and [thenCall] are one-shot so you would\ntypically call these more than once to specify a sequence of actions;\nthis can be done with chained calls, e.g.:\n\n     m.when(callsTo('foo')).\n         thenReturn(0).thenReturn(1).thenReturn(2);\n\n[thenCall] and [alwaysCall] allow you to proxy mocked methods, chaining\nto some other implementation. This provides a way to implement 'spies'.\n\nYou can disable logging for a particular [Behavior] easily:\n\n    m.when(callsTo('bar')).logging = false;\n\nYou can then use the mock object. Once you are done, to verify the\nbehavior, use [getLogs] to extract a relevant subset of method call\nlogs and apply [Matchers] to these through calling [verify].\n\nA Mock can be given a name when constructed. In this case instead of\nkeeping its own log, it uses a shared log. This can be useful to get an\naudit trail of interleaved behavior. It is the responsibility of the user\nto ensure that mock names, if used, are unique.\n\nLimitations:\n\n* only positional parameters are supported (up to 10);\n* to mock getters you will need to include parentheses in the call\n      (e.g. m.length() will work but not m.length).\n\nHere is a simple example:\n\n    class MockList extends Mock implements List {};\n\n    List m = new MockList();\n    m.when(callsTo('add', anything)).alwaysReturn(0);\n\n    m.add('foo');\n    m.add('bar');\n\n    getLogs(m, callsTo('add', anything)).verify(happenedExactly(2));\n    getLogs(m, callsTo('add', 'foo')).verify(happenedOnce);\n    getLogs(m, callsTo('add', 'isNull)).verify(neverHappened);\n\nNote that we don't need to provide argument matchers for all arguments,\nbut we do need to provide arguments for all matchers. So this is allowed:\n\n    m.when(callsTo('add')).alwaysReturn(0);\n    m.add(1, 2);\n\nBut this is not allowed and will throw an exception:\n\n    m.when(callsTo('add', anything, anything)).alwaysReturn(0);\n    m.add(1);\n\nHere is a way to implement a 'spy', which is where we log the call\nbut then hand it off to some other function, which is the same\nmethod in a real instance of the class being mocked:\n\n    class Foo {\n      bar(a, b, c) => a + b + c;\n    }\n\n    class MockFoo extends Mock implements Foo {\n      Foo real;\n      MockFoo() {\n        real = new Foo();\n        this.when(callsTo('bar')).alwaysCall(real.bar);\n      }\n    }\n\n","id":"mock","line":"89"}